diff -crB ../../original/mpfr-3.0.0/acinclude.m4 ./acinclude.m4
*** ../../original/mpfr-3.0.0/acinclude.m4	2010-06-10 13:00:14.000000000 +0200
--- ./acinclude.m4	2010-06-10 13:00:14.000000000 +0200
***************
*** 59,64 ****
--- 59,67 ----
  dnl sys/fpu.h - MIPS specific
  AC_CHECK_HEADERS([sys/time.h sys/fpu.h])
  
+ dnl Check how to get `alloca'
+ AC_FUNC_ALLOCA
+ 
  dnl SIZE_MAX macro
  gl_SIZE_MAX
  
diff -crB ../../original/mpfr-3.0.0/configure ./configure
*** ../../original/mpfr-3.0.0/configure	2010-06-10 13:00:51.000000000 +0200
--- ./configure	2010-06-25 15:23:05.000000000 +0200
***************
*** 783,788 ****
--- 783,789 ----
  OBJDUMP
  DLLTOOL
  AS
+ ALLOCA
  MPFR_LIBM
  ANSI2KNR
  U
***************
*** 5622,5627 ****
--- 5623,5819 ----
  done
  
  
+ # The Ultrix 4.2 mips builtin alloca declared by alloca.h only works
+ # for constant arguments.  Useless!
+ { $as_echo "$as_me:${as_lineno-$LINENO}: checking for working alloca.h" >&5
+ $as_echo_n "checking for working alloca.h... " >&6; }
+ if test "${ac_cv_working_alloca_h+set}" = set; then :
+   $as_echo_n "(cached) " >&6
+ else
+   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+ /* end confdefs.h.  */
+ #include <alloca.h>
+ int
+ main ()
+ {
+ char *p = (char *) alloca (2 * sizeof (int));
+ 			  if (p) return 0;
+   ;
+   return 0;
+ }
+ _ACEOF
+ if ac_fn_c_try_link "$LINENO"; then :
+   ac_cv_working_alloca_h=yes
+ else
+   ac_cv_working_alloca_h=no
+ fi
+ rm -f core conftest.err conftest.$ac_objext \
+     conftest$ac_exeext conftest.$ac_ext
+ fi
+ { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_working_alloca_h" >&5
+ $as_echo "$ac_cv_working_alloca_h" >&6; }
+ if test $ac_cv_working_alloca_h = yes; then
+ 
+ $as_echo "#define HAVE_ALLOCA_H 1" >>confdefs.h
+ 
+ fi
+ 
+ { $as_echo "$as_me:${as_lineno-$LINENO}: checking for alloca" >&5
+ $as_echo_n "checking for alloca... " >&6; }
+ if test "${ac_cv_func_alloca_works+set}" = set; then :
+   $as_echo_n "(cached) " >&6
+ else
+   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+ /* end confdefs.h.  */
+ #ifdef __GNUC__
+ # define alloca __builtin_alloca
+ #else
+ # ifdef _MSC_VER
+ #  include <malloc.h>
+ #  define alloca _alloca
+ # else
+ #  ifdef HAVE_ALLOCA_H
+ #   include <alloca.h>
+ #  else
+ #   ifdef _AIX
+  #pragma alloca
+ #   else
+ #    ifndef alloca /* predefined by HP cc +Olibcalls */
+ char *alloca ();
+ #    endif
+ #   endif
+ #  endif
+ # endif
+ #endif
+ 
+ int
+ main ()
+ {
+ char *p = (char *) alloca (1);
+ 				    if (p) return 0;
+   ;
+   return 0;
+ }
+ _ACEOF
+ if ac_fn_c_try_link "$LINENO"; then :
+   ac_cv_func_alloca_works=yes
+ else
+   ac_cv_func_alloca_works=no
+ fi
+ rm -f core conftest.err conftest.$ac_objext \
+     conftest$ac_exeext conftest.$ac_ext
+ fi
+ { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_func_alloca_works" >&5
+ $as_echo "$ac_cv_func_alloca_works" >&6; }
+ 
+ if test $ac_cv_func_alloca_works = yes; then
+ 
+ $as_echo "#define HAVE_ALLOCA 1" >>confdefs.h
+ 
+ else
+   # The SVR3 libPW and SVR4 libucb both contain incompatible functions
+ # that cause trouble.  Some versions do not even contain alloca or
+ # contain a buggy version.  If you still want to use their alloca,
+ # use ar to extract alloca.o from them instead of compiling alloca.c.
+ 
+ ALLOCA=\${LIBOBJDIR}alloca.$ac_objext
+ 
+ $as_echo "#define C_ALLOCA 1" >>confdefs.h
+ 
+ 
+ { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether \`alloca.c' needs Cray hooks" >&5
+ $as_echo_n "checking whether \`alloca.c' needs Cray hooks... " >&6; }
+ if test "${ac_cv_os_cray+set}" = set; then :
+   $as_echo_n "(cached) " >&6
+ else
+   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+ /* end confdefs.h.  */
+ #if defined CRAY && ! defined CRAY2
+ webecray
+ #else
+ wenotbecray
+ #endif
+ 
+ _ACEOF
+ if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+   $EGREP "webecray" >/dev/null 2>&1; then :
+   ac_cv_os_cray=yes
+ else
+   ac_cv_os_cray=no
+ fi
+ rm -f conftest*
+ 
+ fi
+ { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_os_cray" >&5
+ $as_echo "$ac_cv_os_cray" >&6; }
+ if test $ac_cv_os_cray = yes; then
+   for ac_func in _getb67 GETB67 getb67; do
+     as_ac_var=`$as_echo "ac_cv_func_$ac_func" | $as_tr_sh`
+ ac_fn_c_check_func "$LINENO" "$ac_func" "$as_ac_var"
+ eval as_val=\$$as_ac_var
+    if test "x$as_val" = x""yes; then :
+ 
+ cat >>confdefs.h <<_ACEOF
+ #define CRAY_STACKSEG_END $ac_func
+ _ACEOF
+ 
+     break
+ fi
+ 
+   done
+ fi
+ 
+ { $as_echo "$as_me:${as_lineno-$LINENO}: checking stack direction for C alloca" >&5
+ $as_echo_n "checking stack direction for C alloca... " >&6; }
+ if test "${ac_cv_c_stack_direction+set}" = set; then :
+   $as_echo_n "(cached) " >&6
+ else
+   if test "$cross_compiling" = yes; then :
+   ac_cv_c_stack_direction=0
+ else
+   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+ /* end confdefs.h.  */
+ $ac_includes_default
+ int
+ find_stack_direction ()
+ {
+   static char *addr = 0;
+   auto char dummy;
+   if (addr == 0)
+     {
+       addr = &dummy;
+       return find_stack_direction ();
+     }
+   else
+     return (&dummy > addr) ? 1 : -1;
+ }
+ 
+ int
+ main ()
+ {
+   return find_stack_direction () < 0;
+ }
+ _ACEOF
+ if ac_fn_c_try_run "$LINENO"; then :
+   ac_cv_c_stack_direction=1
+ else
+   ac_cv_c_stack_direction=-1
+ fi
+ rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext \
+   conftest.$ac_objext conftest.beam conftest.$ac_ext
+ fi
+ 
+ fi
+ { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_c_stack_direction" >&5
+ $as_echo "$ac_cv_c_stack_direction" >&6; }
+ cat >>confdefs.h <<_ACEOF
+ #define STACK_DIRECTION $ac_cv_c_stack_direction
+ _ACEOF
+ 
+ 
+ fi
+ 
+ 
  
    for ac_header in stdint.h
  do :
***************
*** 7564,7576 ****
  else
    lt_cv_nm_interface="BSD nm"
    echo "int some_variable = 0;" > conftest.$ac_ext
!   (eval echo "\"\$as_me:7567: $ac_compile\"" >&5)
    (eval "$ac_compile" 2>conftest.err)
    cat conftest.err >&5
!   (eval echo "\"\$as_me:7570: $NM \\\"conftest.$ac_objext\\\"\"" >&5)
    (eval "$NM \"conftest.$ac_objext\"" 2>conftest.err > conftest.out)
    cat conftest.err >&5
!   (eval echo "\"\$as_me:7573: output\"" >&5)
    cat conftest.out >&5
    if $GREP 'External.*some_variable' conftest.out > /dev/null; then
      lt_cv_nm_interface="MS dumpbin"
--- 7756,7768 ----
  else
    lt_cv_nm_interface="BSD nm"
    echo "int some_variable = 0;" > conftest.$ac_ext
!   (eval echo "\"\$as_me:7759: $ac_compile\"" >&5)
    (eval "$ac_compile" 2>conftest.err)
    cat conftest.err >&5
!   (eval echo "\"\$as_me:7762: $NM \\\"conftest.$ac_objext\\\"\"" >&5)
    (eval "$NM \"conftest.$ac_objext\"" 2>conftest.err > conftest.out)
    cat conftest.err >&5
!   (eval echo "\"\$as_me:7765: output\"" >&5)
    cat conftest.out >&5
    if $GREP 'External.*some_variable' conftest.out > /dev/null; then
      lt_cv_nm_interface="MS dumpbin"
***************
*** 8772,8778 ****
    ;;
  *-*-irix6*)
    # Find out which ABI we are using.
!   echo '#line 8775 "configure"' > conftest.$ac_ext
    if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_compile\""; } >&5
    (eval $ac_compile) 2>&5
    ac_status=$?
--- 8964,8970 ----
    ;;
  *-*-irix6*)
    # Find out which ABI we are using.
!   echo '#line 8967 "configure"' > conftest.$ac_ext
    if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_compile\""; } >&5
    (eval $ac_compile) 2>&5
    ac_status=$?
***************
*** 10032,10042 ****
     -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
     -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
     -e 's:$: $lt_compiler_flag:'`
!    (eval echo "\"\$as_me:10035: $lt_compile\"" >&5)
     (eval "$lt_compile" 2>conftest.err)
     ac_status=$?
     cat conftest.err >&5
!    echo "$as_me:10039: \$? = $ac_status" >&5
     if (exit $ac_status) && test -s "$ac_outfile"; then
       # The compiler can only warn and ignore the option if not recognized
       # So say no if there are warnings other than the usual output.
--- 10224,10234 ----
     -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
     -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
     -e 's:$: $lt_compiler_flag:'`
!    (eval echo "\"\$as_me:10227: $lt_compile\"" >&5)
     (eval "$lt_compile" 2>conftest.err)
     ac_status=$?
     cat conftest.err >&5
!    echo "$as_me:10231: \$? = $ac_status" >&5
     if (exit $ac_status) && test -s "$ac_outfile"; then
       # The compiler can only warn and ignore the option if not recognized
       # So say no if there are warnings other than the usual output.
***************
*** 10371,10381 ****
     -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
     -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
     -e 's:$: $lt_compiler_flag:'`
!    (eval echo "\"\$as_me:10374: $lt_compile\"" >&5)
     (eval "$lt_compile" 2>conftest.err)
     ac_status=$?
     cat conftest.err >&5
!    echo "$as_me:10378: \$? = $ac_status" >&5
     if (exit $ac_status) && test -s "$ac_outfile"; then
       # The compiler can only warn and ignore the option if not recognized
       # So say no if there are warnings other than the usual output.
--- 10563,10573 ----
     -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
     -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
     -e 's:$: $lt_compiler_flag:'`
!    (eval echo "\"\$as_me:10566: $lt_compile\"" >&5)
     (eval "$lt_compile" 2>conftest.err)
     ac_status=$?
     cat conftest.err >&5
!    echo "$as_me:10570: \$? = $ac_status" >&5
     if (exit $ac_status) && test -s "$ac_outfile"; then
       # The compiler can only warn and ignore the option if not recognized
       # So say no if there are warnings other than the usual output.
***************
*** 10476,10486 ****
     -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
     -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
     -e 's:$: $lt_compiler_flag:'`
!    (eval echo "\"\$as_me:10479: $lt_compile\"" >&5)
     (eval "$lt_compile" 2>out/conftest.err)
     ac_status=$?
     cat out/conftest.err >&5
!    echo "$as_me:10483: \$? = $ac_status" >&5
     if (exit $ac_status) && test -s out/conftest2.$ac_objext
     then
       # The compiler can only warn and ignore the option if not recognized
--- 10668,10678 ----
     -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
     -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
     -e 's:$: $lt_compiler_flag:'`
!    (eval echo "\"\$as_me:10671: $lt_compile\"" >&5)
     (eval "$lt_compile" 2>out/conftest.err)
     ac_status=$?
     cat out/conftest.err >&5
!    echo "$as_me:10675: \$? = $ac_status" >&5
     if (exit $ac_status) && test -s out/conftest2.$ac_objext
     then
       # The compiler can only warn and ignore the option if not recognized
***************
*** 10531,10541 ****
     -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
     -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
     -e 's:$: $lt_compiler_flag:'`
!    (eval echo "\"\$as_me:10534: $lt_compile\"" >&5)
     (eval "$lt_compile" 2>out/conftest.err)
     ac_status=$?
     cat out/conftest.err >&5
!    echo "$as_me:10538: \$? = $ac_status" >&5
     if (exit $ac_status) && test -s out/conftest2.$ac_objext
     then
       # The compiler can only warn and ignore the option if not recognized
--- 10723,10733 ----
     -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
     -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
     -e 's:$: $lt_compiler_flag:'`
!    (eval echo "\"\$as_me:10726: $lt_compile\"" >&5)
     (eval "$lt_compile" 2>out/conftest.err)
     ac_status=$?
     cat out/conftest.err >&5
!    echo "$as_me:10730: \$? = $ac_status" >&5
     if (exit $ac_status) && test -s out/conftest2.$ac_objext
     then
       # The compiler can only warn and ignore the option if not recognized
***************
*** 12915,12921 ****
    lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
    lt_status=$lt_dlunknown
    cat > conftest.$ac_ext <<_LT_EOF
! #line 12918 "configure"
  #include "confdefs.h"
  
  #if HAVE_DLFCN_H
--- 13107,13113 ----
    lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
    lt_status=$lt_dlunknown
    cat > conftest.$ac_ext <<_LT_EOF
! #line 13110 "configure"
  #include "confdefs.h"
  
  #if HAVE_DLFCN_H
***************
*** 13011,13017 ****
    lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
    lt_status=$lt_dlunknown
    cat > conftest.$ac_ext <<_LT_EOF
! #line 13014 "configure"
  #include "confdefs.h"
  
  #if HAVE_DLFCN_H
--- 13203,13209 ----
    lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
    lt_status=$lt_dlunknown
    cat > conftest.$ac_ext <<_LT_EOF
! #line 13206 "configure"
  #include "confdefs.h"
  
  #if HAVE_DLFCN_H
diff -crB ../../original/mpfr-3.0.0/gamma.c ./gamma.c
*** ../../original/mpfr-3.0.0/gamma.c	2010-06-10 13:00:14.000000000 +0200
--- ./gamma.c	2010-07-10 02:11:46.000000000 +0200
***************
*** 274,280 ****
        /* we want an upper bound for x * [log(2-x)-1].
           since x < 0, we need a lower bound on log(2-x) */
        mpfr_ui_sub (xp, 2, x, MPFR_RNDD);
!       mpfr_log (xp, xp, MPFR_RNDD);
        mpfr_sub_ui (xp, xp, 1, MPFR_RNDD);
        mpfr_mul (xp, xp, x, MPFR_RNDU);
  
--- 274,280 ----
        /* we want an upper bound for x * [log(2-x)-1].
           since x < 0, we need a lower bound on log(2-x) */
        mpfr_ui_sub (xp, 2, x, MPFR_RNDD);
!       mpfr_log2 (xp, xp, MPFR_RNDD);
        mpfr_sub_ui (xp, xp, 1, MPFR_RNDD);
        mpfr_mul (xp, xp, x, MPFR_RNDU);
  
***************
*** 303,310 ****
          {
            mpfr_sub (tmp, tmp, tmp2, MPFR_RNDZ); /* low bnd on |sin(Pi*(2-x))| */
            mpfr_ui_div (tmp, 12, tmp, MPFR_RNDU); /* upper bound */
!           mpfr_log (tmp, tmp, MPFR_RNDU);
!           mpfr_add (tmp, tmp, xp, MPFR_RNDU);
            underflow = mpfr_cmp_si (xp, expo.saved_emin - 2) <= 0;
          }
  
--- 303,310 ----
          {
            mpfr_sub (tmp, tmp, tmp2, MPFR_RNDZ); /* low bnd on |sin(Pi*(2-x))| */
            mpfr_ui_div (tmp, 12, tmp, MPFR_RNDU); /* upper bound */
!           mpfr_log2 (tmp, tmp, MPFR_RNDU);
!           mpfr_add (xp, tmp, xp, MPFR_RNDU);
            underflow = mpfr_cmp_si (xp, expo.saved_emin - 2) <= 0;
          }
  
diff -crB ../../original/mpfr-3.0.0/get_patches.c ./get_patches.c
*** ../../original/mpfr-3.0.0/get_patches.c	2010-06-10 13:01:57.000000000 +0200
--- ./get_patches.c	2010-11-29 16:52:23.000000000 +0100
***************
*** 25,29 ****
  const char *
  mpfr_get_patches (void)
  {
!   return "";
  }
--- 25,29 ----
  const char *
  mpfr_get_patches (void)
  {
!   return "macros mpfr_set_ld mpfr_sub1 tcan_round mpfr_cmp/set_ui/si gamma_underflow alloca mpfr_out_str";
  }
diff -crB ../../original/mpfr-3.0.0/get_str.c ./get_str.c
*** ../../original/mpfr-3.0.0/get_str.c	2010-06-10 13:00:14.000000000 +0200
--- ./get_str.c	2010-11-29 23:25:07.000000000 +0100
***************
*** 2269,2275 ****
      {
        if (s == NULL)
          s = (char *) (*__gmp_allocate_func) (6);
!       strcpy (s, "@NaN@");
        return s;
      }
  
--- 2269,2275 ----
      {
        if (s == NULL)
          s = (char *) (*__gmp_allocate_func) (6);
!       __MPFR_STRCPY (s, "@NaN@");
        return s;
      }
  
***************
*** 2279,2285 ****
      {
        if (s == NULL)
          s = (char *) (*__gmp_allocate_func) (neg + 6);
!       strcpy (s, (neg) ? "-@Inf@" : "@Inf@");
        return s;
      }
  
--- 2279,2285 ----
      {
        if (s == NULL)
          s = (char *) (*__gmp_allocate_func) (neg + 6);
!       __MPFR_STRCPY (s, (neg) ? "-@Inf@" : "@Inf@");
        return s;
      }
  
***************
*** 2550,2554 ****
  
  void mpfr_free_str (char *str)
  {
!    (*__gmp_free_func) (str, strlen (str) + 1);
  }
--- 2550,2554 ----
  
  void mpfr_free_str (char *str)
  {
!    (*__gmp_free_func) (str, __MPFR_STRLEN (str) + 1);
  }
diff -crB ../../original/mpfr-3.0.0/Makefile.am ./Makefile.am
*** ../../original/mpfr-3.0.0/Makefile.am	2010-06-10 13:00:14.000000000 +0200
--- ./Makefile.am	2010-11-29 19:52:37.000000000 +0100
***************
*** 56,62 ****
  zeta_ui.c set_d64.c get_d64.c jn.c yn.c rem1.c get_patches.c add_d.c	\
  sub_d.c d_sub.c mul_d.c div_d.c d_div.c li2.c rec_sqrt.c min_prec.c	\
  buildopt.c digamma.c bernoulli.c isregular.c set_flt.c get_flt.c	\
! scale2.c set_z_exp.c ai.c gammaonethird.c
  
  libmpfr_la_LIBADD = @LIBOBJS@
  
--- 56,62 ----
  zeta_ui.c set_d64.c get_d64.c jn.c yn.c rem1.c get_patches.c add_d.c	\
  sub_d.c d_sub.c mul_d.c div_d.c d_div.c li2.c rec_sqrt.c min_prec.c	\
  buildopt.c digamma.c bernoulli.c isregular.c set_flt.c get_flt.c	\
! scale2.c set_z_exp.c ai.c gammaonethird.c valgrind_additions.c
  
  libmpfr_la_LIBADD = @LIBOBJS@
  
diff -crB ../../original/mpfr-3.0.0/Makefile.in ./Makefile.in
*** ../../original/mpfr-3.0.0/Makefile.in	2010-06-10 13:00:52.000000000 +0200
--- ./Makefile.in	2010-11-29 19:54:49.000000000 +0100
***************
*** 141,147 ****
  	d_div$U.lo li2$U.lo rec_sqrt$U.lo min_prec$U.lo buildopt$U.lo \
  	digamma$U.lo bernoulli$U.lo isregular$U.lo set_flt$U.lo \
  	get_flt$U.lo scale2$U.lo set_z_exp$U.lo ai$U.lo \
! 	gammaonethird$U.lo
  libmpfr_la_OBJECTS = $(am_libmpfr_la_OBJECTS)
  libmpfr_la_LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) \
  	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \
--- 141,147 ----
  	d_div$U.lo li2$U.lo rec_sqrt$U.lo min_prec$U.lo buildopt$U.lo \
  	digamma$U.lo bernoulli$U.lo isregular$U.lo set_flt$U.lo \
  	get_flt$U.lo scale2$U.lo set_z_exp$U.lo ai$U.lo \
! 	gammaonethird$U.lo valgrind_additions$U.lo
  libmpfr_la_OBJECTS = $(am_libmpfr_la_OBJECTS)
  libmpfr_la_LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) \
  	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \
***************
*** 239,244 ****
--- 239,245 ----
  distuninstallcheck_listfiles = find . -type f -print
  distcleancheck_listfiles = find . -type f -print
  ACLOCAL = @ACLOCAL@
+ ALLOCA = @ALLOCA@
  AMTAR = @AMTAR@
  AR = @AR@
  AS = @AS@
***************
*** 396,402 ****
  zeta_ui.c set_d64.c get_d64.c jn.c yn.c rem1.c get_patches.c add_d.c	\
  sub_d.c d_sub.c mul_d.c div_d.c d_div.c li2.c rec_sqrt.c min_prec.c	\
  buildopt.c digamma.c bernoulli.c isregular.c set_flt.c get_flt.c	\
! scale2.c set_z_exp.c ai.c gammaonethird.c
  
  libmpfr_la_LIBADD = @LIBOBJS@
  
--- 397,403 ----
  zeta_ui.c set_d64.c get_d64.c jn.c yn.c rem1.c get_patches.c add_d.c	\
  sub_d.c d_sub.c mul_d.c div_d.c d_div.c li2.c rec_sqrt.c min_prec.c	\
  buildopt.c digamma.c bernoulli.c isregular.c set_flt.c get_flt.c	\
! scale2.c set_z_exp.c ai.c gammaonethird.c valgrind_additions.c
  
  libmpfr_la_LIBADD = @LIBOBJS@
  
***************
*** 738,743 ****
--- 739,745 ----
  @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ui_sub$U.Plo@am__quote@
  @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/urandom$U.Plo@am__quote@
  @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/urandomb$U.Plo@am__quote@
+ @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/valgrind_additions$U.Plo@am__quote@
  @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/vasprintf$U.Plo@am__quote@
  @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/version$U.Plo@am__quote@
  @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/volatile$U.Plo@am__quote@
***************
*** 1191,1196 ****
--- 1193,1200 ----
  	$(CPP) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) `if test -f $(srcdir)/urandom.c; then echo $(srcdir)/urandom.c; else echo urandom.c; fi` | sed 's/^# \([0-9]\)/#line \1/' | $(ANSI2KNR) > $@ || rm -f $@
  urandomb_.c: urandomb.c $(ANSI2KNR)
  	$(CPP) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) `if test -f $(srcdir)/urandomb.c; then echo $(srcdir)/urandomb.c; else echo urandomb.c; fi` | sed 's/^# \([0-9]\)/#line \1/' | $(ANSI2KNR) > $@ || rm -f $@
+ valgrind_additions_.c: valgrind_additions.c $(ANSI2KNR)
+ 	$(CPP) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) `if test -f $(srcdir)/valgrind_additions.c; then echo $(srcdir)/valgrind_additions.c; else echo valgrind_additions.c; fi` | sed 's/^# \([0-9]\)/#line \1/' | $(ANSI2KNR) > $@ || rm -f $@
  vasprintf_.c: vasprintf.c $(ANSI2KNR)
  	$(CPP) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) `if test -f $(srcdir)/vasprintf.c; then echo $(srcdir)/vasprintf.c; else echo vasprintf.c; fi` | sed 's/^# \([0-9]\)/#line \1/' | $(ANSI2KNR) > $@ || rm -f $@
  version_.c: version.c $(ANSI2KNR)
***************
*** 1303,1309 ****
  ufloor_log2_.$(OBJEXT) ufloor_log2_.lo ui_div_.$(OBJEXT) ui_div_.lo \
  ui_pow_.$(OBJEXT) ui_pow_.lo ui_pow_ui_.$(OBJEXT) ui_pow_ui_.lo \
  ui_sub_.$(OBJEXT) ui_sub_.lo urandom_.$(OBJEXT) urandom_.lo \
! urandomb_.$(OBJEXT) urandomb_.lo vasprintf_.$(OBJEXT) vasprintf_.lo \
  version_.$(OBJEXT) version_.lo volatile_.$(OBJEXT) volatile_.lo \
  yn_.$(OBJEXT) yn_.lo zeta_.$(OBJEXT) zeta_.lo zeta_ui_.$(OBJEXT) \
  zeta_ui_.lo : $(ANSI2KNR)
--- 1307,1314 ----
  ufloor_log2_.$(OBJEXT) ufloor_log2_.lo ui_div_.$(OBJEXT) ui_div_.lo \
  ui_pow_.$(OBJEXT) ui_pow_.lo ui_pow_ui_.$(OBJEXT) ui_pow_ui_.lo \
  ui_sub_.$(OBJEXT) ui_sub_.lo urandom_.$(OBJEXT) urandom_.lo \
! urandomb_.$(OBJEXT) urandomb_.lo valgrind_additions_.$(OBJEXT) \
! valgrind_additions_.lo vasprintf_.$(OBJEXT) vasprintf_.lo \
  version_.$(OBJEXT) version_.lo volatile_.$(OBJEXT) volatile_.lo \
  yn_.$(OBJEXT) yn_.lo zeta_.$(OBJEXT) zeta_.lo zeta_ui_.$(OBJEXT) \
  zeta_ui_.lo : $(ANSI2KNR)
diff -crB ../../original/mpfr-3.0.0/mpfr-gmp.c ./mpfr-gmp.c
*** ../../original/mpfr-3.0.0/mpfr-gmp.c	2010-06-10 13:00:14.000000000 +0200
--- ./mpfr-gmp.c	2010-11-29 17:10:58.000000000 +0100
***************
*** 297,307 ****
  {
    if (filename != NULL && filename[0] != '\0')
      {
!       fprintf (stderr, "%s:", filename);
        if (linenum != -1)
!         fprintf (stderr, "%d: ", linenum);
      }
!   fprintf (stderr, "MPFR assertion failed: %s\n", expr);
    abort();
  }
  
--- 297,307 ----
  {
    if (filename != NULL && filename[0] != '\0')
      {
!       /*fprintf (stderr, "%s:", filename);
        if (linenum != -1)
!         fprintf (stderr, "%d: ", linenum);*/
      }
!   //fprintf (stderr, "MPFR assertion failed: %s\n", expr);
    abort();
  }
  
***************
*** 324,334 ****
  mpfr_default_allocate (size_t size)
  {
    void *ret;
!   ret = malloc (size);
    if (ret == NULL)
      {
!       fprintf (stderr, "MPFR: Can't allocate memory (size=%lu)\n",
!                (unsigned long) size);
        abort ();
      }
    return ret;
--- 324,334 ----
  mpfr_default_allocate (size_t size)
  {
    void *ret;
!   //ret = malloc (size);
    if (ret == NULL)
      {
!       /*fprintf (stderr, "MPFR: Can't allocate memory (size=%lu)\n",
!                (unsigned long) size);*/
        abort ();
      }
    return ret;
***************
*** 338,349 ****
  mpfr_default_reallocate (void *oldptr, size_t old_size, size_t new_size)
  {
    void *ret;
!   ret = realloc (oldptr, new_size);
    if (ret == NULL)
      {
!       fprintf (stderr,
                 "MPFR: Can't reallocate memory (old_size=%lu new_size=%lu)\n",
!                (unsigned long) old_size, (unsigned long) new_size);
        abort ();
      }
    return ret;
--- 338,349 ----
  mpfr_default_reallocate (void *oldptr, size_t old_size, size_t new_size)
  {
    void *ret;
!   //ret = realloc (oldptr, new_size);
    if (ret == NULL)
      {
!       /*fprintf (stderr,
                 "MPFR: Can't reallocate memory (old_size=%lu new_size=%lu)\n",
!                (unsigned long) old_size, (unsigned long) new_size);*/
        abort ();
      }
    return ret;
***************
*** 352,358 ****
  void
  mpfr_default_free (void *blk_ptr, size_t blk_size)
  {
!   free (blk_ptr);
  }
  
  void *
--- 352,358 ----
  void
  mpfr_default_free (void *blk_ptr, size_t blk_size)
  {
!   //free (blk_ptr);
  }
  
  void *
diff -crB ../../original/mpfr-3.0.0/mpfr-gmp.h ./mpfr-gmp.h
*** ../../original/mpfr-3.0.0/mpfr-gmp.h	2010-06-10 13:00:14.000000000 +0200
--- ./mpfr-gmp.h	2010-11-30 00:14:33.000000000 +0100
***************
*** 94,102 ****
  #define SHRT_HIGHBIT       SHRT_MIN
  
  /* MP_LIMB macros */
! #define MPN_ZERO(dst, n) memset((dst), 0, (n)*BYTES_PER_MP_LIMB)
! #define MPN_COPY_DECR(dst,src,n) memmove((dst),(src),(n)*BYTES_PER_MP_LIMB)
! #define MPN_COPY_INCR(dst,src,n) memmove((dst),(src),(n)*BYTES_PER_MP_LIMB)
  #define MPN_COPY(dst,src,n) \
    do                                                                  \
      {                                                                 \
--- 94,102 ----
  #define SHRT_HIGHBIT       SHRT_MIN
  
  /* MP_LIMB macros */
! #define MPN_ZERO(dst, n) __MPFR_MEMSET((dst), 0, (n)*BYTES_PER_MP_LIMB)
! #define MPN_COPY_DECR(dst,src,n) __MPFR_MEMMOVE((dst),(src),(n)*BYTES_PER_MP_LIMB)
! #define MPN_COPY_INCR(dst,src,n) __MPFR_MEMMOVE((dst),(src),(n)*BYTES_PER_MP_LIMB)
  #define MPN_COPY(dst,src,n) \
    do                                                                  \
      {                                                                 \
diff -crB ../../original/mpfr-3.0.0/mpfr.h ./mpfr.h
*** ../../original/mpfr-3.0.0/mpfr.h	2010-06-10 13:00:14.000000000 +0200
--- ./mpfr.h	2010-11-30 00:14:53.000000000 +0100
***************
*** 27,33 ****
  #define MPFR_VERSION_MAJOR 3
  #define MPFR_VERSION_MINOR 0
  #define MPFR_VERSION_PATCHLEVEL 0
! #define MPFR_VERSION_STRING "3.0.0"
  
  /* Macros dealing with MPFR VERSION */
  #define MPFR_VERSION_NUM(a,b,c) (((a) << 16L) | ((b) << 8) | (c))
--- 27,33 ----
  #define MPFR_VERSION_MAJOR 3
  #define MPFR_VERSION_MINOR 0
  #define MPFR_VERSION_PATCHLEVEL 0
! #define MPFR_VERSION_STRING "3.0.0-p8"
  
  /* Macros dealing with MPFR VERSION */
  #define MPFR_VERSION_NUM(a,b,c) (((a) << 16L) | ((b) << 8) | (c))
***************
*** 67,72 ****
--- 67,82 ----
  # define _MPFR_H_HAVE_INTMAX_T 1
  #endif
  
+ /* Avoid some problems with macro expansion if the user defines macros
+    with the same name as keywords. By convention, identifiers and macro
+    names starting with mpfr_ are reserved by MPFR. */
+ typedef void            mpfr_void;
+ typedef int             mpfr_int;
+ typedef unsigned int    mpfr_uint;
+ typedef long            mpfr_long;
+ typedef unsigned long   mpfr_ulong;
+ typedef size_t          mpfr_size_t;
+ 
  /* Definition of rounding modes (DON'T USE MPFR_RNDNA!).
     Warning! Changing the contents of this enum should be seen as an
     interface change since the old and the new types are not compatible
***************
*** 136,142 ****
  typedef mp_exp_t     mpfr_exp_t;
  
  /* Definition of the standard exponent limits */
! #define MPFR_EMAX_DEFAULT ((mpfr_exp_t) (((unsigned long) 1 << 30) - 1))
  #define MPFR_EMIN_DEFAULT (-(MPFR_EMAX_DEFAULT))
  
  /* Definition of the main structure */
--- 146,152 ----
  typedef mp_exp_t     mpfr_exp_t;
  
  /* Definition of the standard exponent limits */
! #define MPFR_EMAX_DEFAULT ((mpfr_exp_t) (((mpfr_ulong) 1 << 30) - 1))
  #define MPFR_EMIN_DEFAULT (-(MPFR_EMAX_DEFAULT))
  
  /* Definition of the main structure */
***************
*** 231,236 ****
--- 241,272 ----
  extern "C" {
  #endif
  
+ /* fbenz: additions, needed if MPFR is used within a Valgrind tool */
+ __MPFR_DECLSPEC void mpfr_set_strlen_function _MPFR_PROTO((size_t (*)(const char*)));
+ __MPFR_DECLSPEC void mpfr_set_strcpy_function _MPFR_PROTO((char* (*)(char*, const char*)));
+ __MPFR_DECLSPEC void mpfr_set_memmove_function _MPFR_PROTO((void* (*)(void*, const void*, size_t)));
+ __MPFR_DECLSPEC void mpfr_set_memcmp_function _MPFR_PROTO((int (*)(const void*, const void*, size_t)));
+ __MPFR_DECLSPEC void mpfr_set_memset_function _MPFR_PROTO((void* (*)(void*, int, size_t)));
+ /* fbenz: this part should better be hidden in mpfe-impl.h
+    but it does not work at the moment */
+ __MPFR_DECLSPEC size_t (*__mpfr_strlen_func) _MPFR_PROTO ((const char*));
+ #define __MPFR_STRLEN(s) \
+   ((*__mpfr_strlen_func) (s))
+ __MPFR_DECLSPEC char* (*__mpfr_strcpy_func) _MPFR_PROTO ((char*, const char*));
+ #define __MPFR_STRCPY(s1,s2) \
+   ((*__mpfr_strcpy_func) (s1,s2))
+ __MPFR_DECLSPEC void* (*__mpfr_memmove_func) _MPFR_PROTO ((void*, const void*, size_t));
+ #define __MPFR_MEMMOVE(p1,p2,t) \
+   ((*__mpfr_memmove_func) (p1,p2,t))
+ __MPFR_DECLSPEC int (*__mpfr_memcmp_func) _MPFR_PROTO ((const void*, const void*, size_t));
+ #define __MPFR_MEMCMP(p1,p2,t) \
+   ((*__mpfr_memmove_func) (p1,p2,t))
+ __MPFR_DECLSPEC void* (*__mpfr_memset_func) _MPFR_PROTO ((void*, int, size_t));
+ #define __MPFR_MEMSET(p,i,t) \
+   ((*__mpfr_memset_func) (p,i,t))
+ 
+ 
+ 
  __MPFR_DECLSPEC __gmp_const char * mpfr_get_version _MPFR_PROTO ((void));
  __MPFR_DECLSPEC __gmp_const char * mpfr_get_patches _MPFR_PROTO ((void));
  __MPFR_DECLSPEC int mpfr_buildopt_tls_p     _MPFR_PROTO ((void));
***************
*** 725,737 ****
     unexpected results with future compilers and aggressive optimisations.
     Why not working only with signed types, using INT_MIN and LONG_MIN? */
  #if __GMP_MP_SIZE_T_INT
! #define __MPFR_EXP_NAN  ((mpfr_exp_t)((~((~(unsigned int)0)>>1))+2))
! #define __MPFR_EXP_ZERO ((mpfr_exp_t)((~((~(unsigned int)0)>>1))+1))
! #define __MPFR_EXP_INF  ((mpfr_exp_t)((~((~(unsigned int)0)>>1))+3))
  #else
! #define __MPFR_EXP_NAN  ((mpfr_exp_t)((~((~(unsigned long)0)>>1))+2))
! #define __MPFR_EXP_ZERO ((mpfr_exp_t)((~((~(unsigned long)0)>>1))+1))
! #define __MPFR_EXP_INF  ((mpfr_exp_t)((~((~(unsigned long)0)>>1))+3))
  #endif
  
  /* Define MPFR_USE_EXTENSION to avoid "gcc -pedantic" warnings. */
--- 761,773 ----
     unexpected results with future compilers and aggressive optimisations.
     Why not working only with signed types, using INT_MIN and LONG_MIN? */
  #if __GMP_MP_SIZE_T_INT
! #define __MPFR_EXP_NAN  ((mpfr_exp_t)((~((~(mpfr_uint)0)>>1))+2))
! #define __MPFR_EXP_ZERO ((mpfr_exp_t)((~((~(mpfr_uint)0)>>1))+1))
! #define __MPFR_EXP_INF  ((mpfr_exp_t)((~((~(mpfr_uint)0)>>1))+3))
  #else
! #define __MPFR_EXP_NAN  ((mpfr_exp_t)((~((~(mpfr_ulong)0)>>1))+2))
! #define __MPFR_EXP_ZERO ((mpfr_exp_t)((~((~(mpfr_ulong)0)>>1))+1))
! #define __MPFR_EXP_INF  ((mpfr_exp_t)((~((~(mpfr_ulong)0)>>1))+3))
  #endif
  
  /* Define MPFR_USE_EXTENSION to avoid "gcc -pedantic" warnings. */
***************
*** 760,768 ****
  #define mpfr_inf_p(_x)      ((_x)->_mpfr_exp == __MPFR_EXP_INF)
  #define mpfr_zero_p(_x)     ((_x)->_mpfr_exp == __MPFR_EXP_ZERO)
  #define mpfr_regular_p(_x)  ((_x)->_mpfr_exp >  __MPFR_EXP_INF)
! #define mpfr_sgn(_x)                                          \
!   ((_x)->_mpfr_exp < __MPFR_EXP_INF ?                         \
!    (mpfr_nan_p (_x) ? mpfr_set_erangeflag () : (void) 0), 0 : \
     MPFR_SIGN (_x))
  
  /* Prevent them from using as lvalues */
--- 796,804 ----
  #define mpfr_inf_p(_x)      ((_x)->_mpfr_exp == __MPFR_EXP_INF)
  #define mpfr_zero_p(_x)     ((_x)->_mpfr_exp == __MPFR_EXP_ZERO)
  #define mpfr_regular_p(_x)  ((_x)->_mpfr_exp >  __MPFR_EXP_INF)
! #define mpfr_sgn(_x)                                               \
!   ((_x)->_mpfr_exp < __MPFR_EXP_INF ?                              \
!    (mpfr_nan_p (_x) ? mpfr_set_erangeflag () : (mpfr_void) 0), 0 : \
     MPFR_SIGN (_x))
  
  /* Prevent them from using as lvalues */
***************
*** 798,847 ****
       anyway. Checking with other ICC versions is needed. Possibly detect
       whether warnings are produced or not with a configure test.
     + Remove C++ too, since it complains too much. */
  #if defined (__GNUC__) && !defined(__ICC) && !defined(__cplusplus)
  #if (__GNUC__ >= 2)
  #undef mpfr_cmp_ui
! /* We use the fact that mpfr_sgn on NaN sets the erange flag and returns 0. */
! #define mpfr_cmp_ui(_f,_u)                 \
!  (__builtin_constant_p (_u) && (_u) == 0 ? \
!    mpfr_sgn (_f) :                         \
!    mpfr_cmp_ui_2exp ((_f),(_u),0))
  #undef mpfr_cmp_si
! #define mpfr_cmp_si(_f,_s)                 \
!  (__builtin_constant_p (_s) && (_s) >= 0 ? \
!    mpfr_cmp_ui ((_f), (_s)) :              \
     mpfr_cmp_si_2exp ((_f), (_s), 0))
  #if __GNUC__ > 2 || __GNUC_MINOR__ >= 95
  #undef mpfr_set_ui
! #define mpfr_set_ui(_f,_u,_r)              \
!  (__builtin_constant_p (_u) && (_u) == 0 ? \
!    __extension__ ({                        \
!      mpfr_ptr _p = (_f);                   \
!      _p->_mpfr_sign = 1;                   \
!      _p->_mpfr_exp = __MPFR_EXP_ZERO;      \
!      (void) (_r); 0; }) :                  \
     mpfr_set_ui_2exp ((_f), (_u), 0, (_r)))
  #endif
  #undef mpfr_set_si
! #define mpfr_set_si(_f,_s,_r)              \
!  (__builtin_constant_p (_s) && (_s) >= 0 ? \
!    mpfr_set_ui ((_f), (_s), (_r)) :        \
     mpfr_set_si_2exp ((_f), (_s), 0, (_r)))
  #endif
  #endif
  
  /* Macro version of mpfr_stack interface for fast access */
! #define mpfr_custom_get_size(p) ((size_t)                            \
         (((p)+GMP_NUMB_BITS-1)/GMP_NUMB_BITS*sizeof (mp_limb_t)))
  #define mpfr_custom_init(m,p) do {} while (0)
! #define mpfr_custom_get_significand(x) ((void*)((x)->_mpfr_d))
  #define mpfr_custom_get_exp(x) ((x)->_mpfr_exp)
  #define mpfr_custom_move(x,m) do { ((x)->_mpfr_d = (mp_limb_t*)(m)); } while (0)
  #define mpfr_custom_init_set(x,k,e,p,m) do {                   \
    mpfr_ptr _x = (x);                                           \
    mpfr_exp_t _e;                                               \
    mpfr_kind_t _t;                                              \
!   int _s, _k;                                                  \
    _k = (k);                                                    \
    if (_k >= 0)  {                                              \
      _t = (mpfr_kind_t) _k;                                     \
--- 834,905 ----
       anyway. Checking with other ICC versions is needed. Possibly detect
       whether warnings are produced or not with a configure test.
     + Remove C++ too, since it complains too much. */
+ /* Added casts to improve robustness in case of undefined behavior and
+    compiler extensions based on UB (in particular -fwrapv). MPFR doesn't
+    use such extensions, but these macros will be used by 3rd-party code,
+    where such extensions may be required.
+    Moreover casts to unsigned long have been added to avoid warnings in
+    programs that use MPFR and are compiled with -Wconversion; such casts
+    are OK since if X is a constant expression, then (unsigned long) X is
+    also a constant expression, so that the optimizations still work. The
+    warnings are probably related to the following two bugs:
+      http://gcc.gnu.org/bugzilla/show_bug.cgi?id=4210
+      http://gcc.gnu.org/bugzilla/show_bug.cgi?id=38470 (possibly a variant)
+    and the casts could be removed once these bugs are fixed.
+    Casts shouldn't be used on the generic calls (to the ..._2exp functions),
+    where implicit conversions are performed. Indeed, having at least one
+    implicit conversion in the macro allows the compiler to emit diagnostics
+    when normally expected, for instance in the following call:
+      mpfr_set_ui (x, "foo", MPFR_RNDN);
+    If this is not possible (for future macros), one of the tricks described
+    on http://groups.google.com/group/comp.std.c/msg/e92abd24bf9eaf7b could
+    be used. */
  #if defined (__GNUC__) && !defined(__ICC) && !defined(__cplusplus)
  #if (__GNUC__ >= 2)
  #undef mpfr_cmp_ui
! /* We use the fact that mpfr_sgn on NaN sets the erange flag and returns 0.
!    But warning! mpfr_sgn is specified as a macro in the API, thus the macro
!    mustn't be used if side effects are possible, like here. */
! #define mpfr_cmp_ui(_f,_u)                                      \
!   (__builtin_constant_p (_u) && (mpfr_ulong) (_u) == 0 ?        \
!    (mpfr_sgn) (_f) :                                            \
!    mpfr_cmp_ui_2exp ((_f), (_u), 0))
  #undef mpfr_cmp_si
! #define mpfr_cmp_si(_f,_s)                                      \
!   (__builtin_constant_p (_s) && (mpfr_long) (_s) >= 0 ?         \
!    mpfr_cmp_ui ((_f), (mpfr_ulong) (mpfr_long) (_s)) :          \
     mpfr_cmp_si_2exp ((_f), (_s), 0))
  #if __GNUC__ > 2 || __GNUC_MINOR__ >= 95
  #undef mpfr_set_ui
! #define mpfr_set_ui(_f,_u,_r)                                   \
!   (__builtin_constant_p (_u) && (mpfr_ulong) (_u) == 0 ?        \
!    __extension__ ({                                             \
!        mpfr_ptr _p = (_f);                                      \
!        _p->_mpfr_sign = 1;                                      \
!        _p->_mpfr_exp = __MPFR_EXP_ZERO;                         \
!        (mpfr_void) (_r); 0; }) :                                \
     mpfr_set_ui_2exp ((_f), (_u), 0, (_r)))
  #endif
  #undef mpfr_set_si
! #define mpfr_set_si(_f,_s,_r)                                   \
!   (__builtin_constant_p (_s) && (mpfr_long) (_s) >= 0 ?         \
!    mpfr_set_ui ((_f), (mpfr_ulong) (mpfr_long) (_s), (_r)) :    \
     mpfr_set_si_2exp ((_f), (_s), 0, (_r)))
  #endif
  #endif
  
  /* Macro version of mpfr_stack interface for fast access */
! #define mpfr_custom_get_size(p) ((mpfr_size_t)                          \
         (((p)+GMP_NUMB_BITS-1)/GMP_NUMB_BITS*sizeof (mp_limb_t)))
  #define mpfr_custom_init(m,p) do {} while (0)
! #define mpfr_custom_get_significand(x) ((mpfr_void*)((x)->_mpfr_d))
  #define mpfr_custom_get_exp(x) ((x)->_mpfr_exp)
  #define mpfr_custom_move(x,m) do { ((x)->_mpfr_d = (mp_limb_t*)(m)); } while (0)
  #define mpfr_custom_init_set(x,k,e,p,m) do {                   \
    mpfr_ptr _x = (x);                                           \
    mpfr_exp_t _e;                                               \
    mpfr_kind_t _t;                                              \
!   mpfr_int _s, _k;                                             \
    _k = (k);                                                    \
    if (_k >= 0)  {                                              \
      _t = (mpfr_kind_t) _k;                                     \
***************
*** 858,868 ****
    _x->_mpfr_exp  = _e;                                         \
    _x->_mpfr_d    = (mp_limb_t*) (m);                           \
   } while (0)
! #define mpfr_custom_get_kind(x)                                              \
!   ( (x)->_mpfr_exp >  __MPFR_EXP_INF ? (int)MPFR_REGULAR_KIND*MPFR_SIGN (x) \
!   : (x)->_mpfr_exp == __MPFR_EXP_INF ? (int)MPFR_INF_KIND*MPFR_SIGN (x)     \
!   : (x)->_mpfr_exp == __MPFR_EXP_NAN ? (int)MPFR_NAN_KIND                   \
!   : (int) MPFR_ZERO_KIND * MPFR_SIGN (x) )
  
  
  #endif /* MPFR_USE_NO_MACRO */
--- 916,928 ----
    _x->_mpfr_exp  = _e;                                         \
    _x->_mpfr_d    = (mp_limb_t*) (m);                           \
   } while (0)
! #define mpfr_custom_get_kind(x)                                         \
!   ( (x)->_mpfr_exp >  __MPFR_EXP_INF ?                                  \
!     (mpfr_int) MPFR_REGULAR_KIND * MPFR_SIGN (x)                        \
!   : (x)->_mpfr_exp == __MPFR_EXP_INF ?                                  \
!     (mpfr_int) MPFR_INF_KIND * MPFR_SIGN (x)                            \
!   : (x)->_mpfr_exp == __MPFR_EXP_NAN ? (mpfr_int) MPFR_NAN_KIND         \
!   : (mpfr_int) MPFR_ZERO_KIND * MPFR_SIGN (x) )
  
  
  #endif /* MPFR_USE_NO_MACRO */
diff -crB ../../original/mpfr-3.0.0/mpfr-impl.h ./mpfr-impl.h
*** ../../original/mpfr-3.0.0/mpfr-impl.h	2010-06-10 13:00:14.000000000 +0200
--- ./mpfr-impl.h	2010-11-29 22:52:51.000000000 +0100
***************
*** 1632,1637 ****
--- 1632,1641 ----
  extern "C" {
  #endif
  
+ /* fbenz: additions, needed if MPFR is used within a Valgrind tool */
+ //__MPFR_DECLSPEC size_t (*__mpfr_strlen_func) _MPFR_PROTO ((const char*));
+ 
+ 
  __MPFR_DECLSPEC int mpfr_underflow _MPFR_PROTO ((mpfr_ptr, mpfr_rnd_t, int));
  __MPFR_DECLSPEC int mpfr_overflow _MPFR_PROTO ((mpfr_ptr, mpfr_rnd_t, int));
  
diff -crB ../../original/mpfr-3.0.0/mpfr.texi ./mpfr.texi
*** ../../original/mpfr-3.0.0/mpfr.texi	2010-06-10 13:00:14.000000000 +0200
--- ./mpfr.texi	2010-06-23 13:03:12.000000000 +0200
***************
*** 2050,2056 ****
  are printed. If @var{base} is greater than 10, @samp{@@} will be used
  instead of @samp{e} as exponent delimiter.
  
! Return the number of bytes written, or if an error occurred, return 0.
  @end deftypefun
  
  @deftypefun size_t mpfr_inp_str (mpfr_t @var{rop}, FILE *@var{stream}, int @var{base}, mpfr_rnd_t @var{rnd})
--- 2050,2056 ----
  are printed. If @var{base} is greater than 10, @samp{@@} will be used
  instead of @samp{e} as exponent delimiter.
  
! Return the number of characters written, or if an error occurred, return 0.
  @end deftypefun
  
  @deftypefun size_t mpfr_inp_str (mpfr_t @var{rop}, FILE *@var{stream}, int @var{base}, mpfr_rnd_t @var{rnd})
diff -crB ../../original/mpfr-3.0.0/out_str.c ./out_str.c
*** ../../original/mpfr-3.0.0/out_str.c	2010-06-10 13:00:14.000000000 +0200
--- ./out_str.c	2010-06-23 13:03:12.000000000 +0200
***************
*** 22,27 ****
--- 22,37 ----
  
  #include "mpfr-impl.h"
  
+ /* Warning! S should not contain "%". */
+ #define OUT_STR_RET(S)                          \
+   do                                            \
+     {                                           \
+       int r;                                    \
+       r = fprintf (stream, (S));                \
+       return r < 0 ? 0 : r;                     \
+     }                                           \
+   while (0)
+ 
  size_t
  mpfr_out_str (FILE *stream, int base, size_t n_digits, mpfr_srcptr op,
                mpfr_rnd_t rnd_mode)
***************
*** 29,34 ****
--- 39,45 ----
    char *s, *s0;
    size_t l;
    mpfr_exp_t e;
+   int err;
  
    MPFR_ASSERTN (base >= 2 && base <= 62);
  
***************
*** 36,72 ****
    if (stream == NULL)
      stream = stdout;
  
!   if (MPFR_IS_NAN(op))
!     {
!       fprintf (stream, "@NaN@");
!       return 3;
!     }
! 
!   if (MPFR_IS_INF(op))
!     {
!       if (MPFR_SIGN(op) > 0)
!         {
!           fprintf (stream, "@Inf@");
!           return 3;
!         }
!       else
!         {
!           fprintf (stream, "-@Inf@");
!           return 4;
!         }
!     }
! 
!   if (MPFR_IS_ZERO(op))
      {
!       if (MPFR_SIGN(op) > 0)
!         {
!           fprintf(stream, "0");
!           return 1;
!         }
        else
          {
!           fprintf(stream, "-0");
!           return 2;
          }
      }
  
--- 47,62 ----
    if (stream == NULL)
      stream = stdout;
  
!   if (MPFR_UNLIKELY (MPFR_IS_SINGULAR (op)))
      {
!       if (MPFR_IS_NAN (op))
!         OUT_STR_RET ("@NaN@");
!       else if (MPFR_IS_INF (op))
!         OUT_STR_RET (MPFR_IS_POS (op) ? "@Inf@" : "-@Inf@");
        else
          {
!           MPFR_ASSERTD (MPFR_IS_ZERO (op));
!           OUT_STR_RET (MPFR_IS_POS (op) ? "0" : "-0");
          }
      }
  
***************
*** 77,97 ****
  
    l = strlen (s) + 1; /* size of allocated block returned by mpfr_get_str
                           - may be incorrect, as only an upper bound? */
-   if (*s == '-')
-     fputc (*s++, stream);
  
!   /* outputs mantissa */
!   fputc (*s++, stream); e--; /* leading digit */
!   fputc ((unsigned char) MPFR_DECIMAL_POINT, stream);
!   fputs (s, stream);         /* rest of mantissa */
    (*__gmp_free_func) (s0, l);
  
    /* outputs exponent */
    if (e)
      {
        MPFR_ASSERTN(e >= LONG_MIN);
        MPFR_ASSERTN(e <= LONG_MAX);
!       l += fprintf (stream, (base <= 10 ? "e%ld" : "@%ld"), (long) e);
      }
  
    return l;
--- 67,97 ----
  
    l = strlen (s) + 1; /* size of allocated block returned by mpfr_get_str
                           - may be incorrect, as only an upper bound? */
  
!   /* outputs possible sign and significand */
!   err = (*s == '-' && fputc (*s++, stream) == EOF)
!     || fputc (*s++, stream) == EOF  /* leading digit */
!     || fputc ((unsigned char) MPFR_DECIMAL_POINT, stream) == EOF
!     || fputs (s, stream) == EOF;     /* trailing significand */
    (*__gmp_free_func) (s0, l);
+   if (MPFR_UNLIKELY (err))
+     return 0;
+ 
+   e--;  /* due to the leading digit */
  
    /* outputs exponent */
    if (e)
      {
+       int r;
+ 
        MPFR_ASSERTN(e >= LONG_MIN);
        MPFR_ASSERTN(e <= LONG_MAX);
! 
!       r = fprintf (stream, (base <= 10 ? "e%ld" : "@%ld"), (long) e);
!       if (MPFR_UNLIKELY (r < 0))
!         return 0;
! 
!       l += r;
      }
  
    return l;
Nur in ./: out_str.lo.
Nur in ./: out_str.o.
diff -crB ../../original/mpfr-3.0.0/PATCHES ./PATCHES
*** ../../original/mpfr-3.0.0/PATCHES	2010-06-10 13:00:14.000000000 +0200
--- ./PATCHES	2010-11-29 16:52:09.000000000 +0100
***************
*** 0 ****
--- 1,8 ----
+ macros
+ mpfr_set_ld
+ mpfr_sub1
+ tcan_round
+ mpfr_cmp/set_ui/si
+ gamma_underflow
+ alloca
+ mpfr_out_str
diff -crB ../../original/mpfr-3.0.0/set_d.c ./set_d.c
*** ../../original/mpfr-3.0.0/set_d.c	2010-06-10 13:00:14.000000000 +0200
--- ./set_d.c	2010-11-29 23:51:15.000000000 +0100
***************
*** 177,185 ****
          /* FIXME: consider the case where +0.0 or -0.0 may have several
             representations. */
          double poszero = +0.0, negzero = DBL_NEG_ZERO;
!         if (memcmp(&d, &poszero, sizeof(double)) == 0)
            MPFR_SET_POS(r);
!         else if (memcmp(&d, &negzero, sizeof(double)) == 0)
            MPFR_SET_NEG(r);
          else
            MPFR_SET_POS(r);
--- 177,185 ----
          /* FIXME: consider the case where +0.0 or -0.0 may have several
             representations. */
          double poszero = +0.0, negzero = DBL_NEG_ZERO;
!         if (__MPFR_MEMCMP(&d, &poszero, sizeof(double)) == 0)
            MPFR_SET_POS(r);
!         else if (__MPFR_MEMCMP(&d, &negzero, sizeof(double)) == 0)
            MPFR_SET_NEG(r);
          else
            MPFR_SET_POS(r);
diff -crB ../../original/mpfr-3.0.0/set_ld.c ./set_ld.c
*** ../../original/mpfr-3.0.0/set_ld.c	2010-06-10 13:00:14.000000000 +0200
--- ./set_ld.c	2010-10-21 23:18:26.000000000 +0200
***************
*** 102,122 ****
--- 102,126 ----
              {
                x /= div13; /* exact */
                shift_exp += 8192;
+               mpfr_div_2si (t, t, 8192, MPFR_RNDZ);
              }
            if (ABS (x) >= div12)
              {
                x /= div12; /* exact */
                shift_exp += 4096;
+               mpfr_div_2si (t, t, 4096, MPFR_RNDZ);
              }
            if (ABS (x) >= div11)
              {
                x /= div11; /* exact */
                shift_exp += 2048;
+               mpfr_div_2si (t, t, 2048, MPFR_RNDZ);
              }
            if (ABS (x) >= div10)
              {
                x /= div10; /* exact */
                shift_exp += 1024;
+               mpfr_div_2si (t, t, 1024, MPFR_RNDZ);
              }
            /* warning: we may have DBL_MAX=2^1024*(1-2^(-53)) < x < 2^1024,
               therefore we have one extra exponent reduction step */
***************
*** 124,132 ****
              {
                x /= div9; /* exact */
                shift_exp += 512;
              }
          } /* Check overflow of double */
!       else
          {
            long double div9, div10, div11;
  
--- 128,137 ----
              {
                x /= div9; /* exact */
                shift_exp += 512;
+               mpfr_div_2si (t, t, 512, MPFR_RNDZ);
              }
          } /* Check overflow of double */
!       else /* no overflow on double */
          {
            long double div9, div10, div11;
  
***************
*** 149,177 ****
                  {
                    x /= div13; /* exact */
                    shift_exp -= 8192;
                  }
                if (ABS (x) <= div12)
                  {
                    x /= div12; /* exact */
                    shift_exp -= 4096;
                  }
                if (ABS (x) <= div11)
                  {
                    x /= div11; /* exact */
                    shift_exp -= 2048;
                  }
                if (ABS (x) <= div10)
                  {
                    x /= div10; /* exact */
                    shift_exp -= 1024;
                  }
                if (ABS(x) <= div9)
                  {
                    x /= div9;  /* exact */
                    shift_exp -= 512;
                  }
              }
!           else
              {
                inexact = mpfr_set_d (u, (double) x, MPFR_RNDZ);
                MPFR_ASSERTD (inexact == 0);
--- 154,187 ----
                  {
                    x /= div13; /* exact */
                    shift_exp -= 8192;
+                   mpfr_mul_2si (t, t, 8192, MPFR_RNDZ);
                  }
                if (ABS (x) <= div12)
                  {
                    x /= div12; /* exact */
                    shift_exp -= 4096;
+                   mpfr_mul_2si (t, t, 4096, MPFR_RNDZ);
                  }
                if (ABS (x) <= div11)
                  {
                    x /= div11; /* exact */
                    shift_exp -= 2048;
+                   mpfr_mul_2si (t, t, 2048, MPFR_RNDZ);
                  }
                if (ABS (x) <= div10)
                  {
                    x /= div10; /* exact */
                    shift_exp -= 1024;
+                   mpfr_mul_2si (t, t, 1024, MPFR_RNDZ);
                  }
                if (ABS(x) <= div9)
                  {
                    x /= div9;  /* exact */
                    shift_exp -= 512;
+                   mpfr_mul_2si (t, t, 512, MPFR_RNDZ);
                  }
              }
!           else /* no underflow */
              {
                inexact = mpfr_set_d (u, (double) x, MPFR_RNDZ);
                MPFR_ASSERTD (inexact == 0);
diff -crB ../../original/mpfr-3.0.0/sub1.c ./sub1.c
*** ../../original/mpfr-3.0.0/sub1.c	2010-06-10 13:00:14.000000000 +0200
--- ./sub1.c	2010-10-21 22:59:32.000000000 +0200
***************
*** 37,43 ****
    mp_size_t cancel2, an, bn, cn, cn0;
    mp_limb_t *ap, *bp, *cp;
    mp_limb_t carry, bb, cc, borrow = 0;
!   int inexact, shift_b, shift_c, is_exact = 1, down = 0, add_exp = 0;
    int sh, k;
    MPFR_TMP_DECL(marker);
  
--- 37,45 ----
    mp_size_t cancel2, an, bn, cn, cn0;
    mp_limb_t *ap, *bp, *cp;
    mp_limb_t carry, bb, cc, borrow = 0;
!   int inexact, shift_b, shift_c, add_exp = 0;
!   int cmp_low = 0; /* used for rounding to nearest: 0 if low(b) = low(c),
!                       negative if low(b) < low(c), positive if low(b)>low(c) */
    int sh, k;
    MPFR_TMP_DECL(marker);
  
***************
*** 196,202 ****
      }
  
  #ifdef DEBUG
!   printf ("shift_b=%d shift_c=%d diffexp=%lu\n", shift_b, shift_c,
            (unsigned long) diff_exp);
  #endif
  
--- 198,205 ----
      }
  
  #ifdef DEBUG
!   printf ("rnd=%s shift_b=%d shift_c=%d diffexp=%lu\n",
!           mpfr_print_rnd_mode (rnd_mode), shift_b, shift_c,
            (unsigned long) diff_exp);
  #endif
  
***************
*** 307,323 ****
      {
        if (MPFR_LIKELY(sh))
          {
-           is_exact = (carry == 0);
            /* can decide except when carry = 2^(sh-1) [middle]
               or carry = 0 [truncate, but cannot decide inexact flag] */
-           down = (carry < (MPFR_LIMB_ONE << (sh - 1)));
            if (carry > (MPFR_LIMB_ONE << (sh - 1)))
              goto add_one_ulp;
!           else if ((0 < carry) && down)
              {
                inexact = -1; /* result if smaller than exact value */
                goto truncate;
              }
          }
      }
    else /* directed rounding: set rnd_mode to RNDZ iff toward zero */
--- 310,327 ----
      {
        if (MPFR_LIKELY(sh))
          {
            /* can decide except when carry = 2^(sh-1) [middle]
               or carry = 0 [truncate, but cannot decide inexact flag] */
            if (carry > (MPFR_LIMB_ONE << (sh - 1)))
              goto add_one_ulp;
!           else if ((0 < carry) && (carry < (MPFR_LIMB_ONE << (sh - 1))))
              {
                inexact = -1; /* result if smaller than exact value */
                goto truncate;
              }
+           /* now carry = 2^(sh-1), in which case cmp_low=2,
+              or carry = 0, in which case cmp_low=0 */
+           cmp_low = (carry == 0) ? 0 : 2;
          }
      }
    else /* directed rounding: set rnd_mode to RNDZ iff toward zero */
***************
*** 344,355 ****
    cn -= (long int) an + cancel2;
  
  #ifdef DEBUG
!   printf ("last %d bits from a are %lu, bn=%ld, cn=%ld\n",
            sh, (unsigned long) carry, (long) bn, (long) cn);
  #endif
  
    for (k = 0; (bn > 0) || (cn > 0); k = 1)
      {
        /* get next limbs */
        bb = (bn > 0) ? bp[--bn] : 0;
        if ((cn > 0) && (cn-- <= cn0))
--- 348,379 ----
    cn -= (long int) an + cancel2;
  
  #ifdef DEBUG
!   printf ("last sh=%d bits from a are %lu, bn=%ld, cn=%ld\n",
            sh, (unsigned long) carry, (long) bn, (long) cn);
  #endif
  
+   /* for rounding to nearest, we couldn't conclude up to here in the following
+      cases:
+      1. sh = 0, then cmp_low=0: we can either truncate, subtract one ulp
+         or add one ulp: -1 ulp < low(b)-low(c) < 1 ulp
+      2. sh > 0 but the low sh bits from high(b)-high(c) equal 2^(sh-1):
+         -0.5 ulp <= -1/2^sh < low(b)-low(c)-0.5 < 1/2^sh <= 0.5 ulp
+         we can't decide the rounding, in that case cmp_low=2:
+         either we truncate and flag=-1, or we add one ulp and flag=1
+      3. the low sh>0 bits from high(b)-high(c) equal 0: we know we have to
+         truncate but we can't decide the ternary value, here cmp_low=0:
+         -0.5 ulp <= -1/2^sh < low(b)-low(c) < 1/2^sh <= 0.5 ulp
+         we always truncate and inexact can be any of -1,0,1
+   */
+ 
+   /* note: here cn might exceed cn0, in which case we consider a zero limb */
    for (k = 0; (bn > 0) || (cn > 0); k = 1)
      {
+       /* if cmp_low < 0, we know low(b) - low(c) < 0
+          if cmp_low > 0, we know low(b) - low(c) > 0
+             (more precisely if cmp_low = 2, low(b) - low(c) = 0.5 ulp so far)
+          if cmp_low = 0, so far low(b) - low(c) = 0 */
+ 
        /* get next limbs */
        bb = (bn > 0) ? bp[--bn] : 0;
        if ((cn > 0) && (cn-- <= cn0))
***************
*** 357,432 ****
        else
          cc = 0;
  
!       /* down is set when low(b) < low(c) */
!       if (down == 0)
!         down = (bb < cc);
  
        /* the case rounding to nearest with sh=0 is special since one couldn't
           subtract above 1/2 ulp in the trailing limb of the result */
!       if ((rnd_mode == MPFR_RNDN) && sh == 0 && k == 0)
          {
            mp_limb_t half = MPFR_LIMB_HIGHBIT;
  
-           is_exact = (bb == cc);
- 
            /* add one ulp if bb > cc + half
               truncate if cc - half < bb < cc + half
               sub one ulp if bb < cc - half
            */
  
!           if (down)
              {
                if (cc >= half)
                  cc -= half;
!               else
                  bb += half;
              }
!           else /* bb >= cc */
              {
                if (cc < half)
                  cc += half;
!               else
                  bb -= half;
              }
          }
  
  #ifdef DEBUG
!       printf ("    bb=%lu cc=%lu down=%d is_exact=%d\n",
!               (unsigned long) bb, (unsigned long) cc, down, is_exact);
  #endif
!       if (bb < cc)
          {
            if (rnd_mode == MPFR_RNDZ)
!             goto sub_one_ulp;
            else if (rnd_mode != MPFR_RNDN) /* round away */
              {
                inexact = 1;
                goto truncate;
              }
!           else /* round to nearest: special case here since for sh=k=0
!                   bb = bb0 - MPFR_LIMB_HIGHBIT */
              {
!               if (is_exact && sh == 0)
!                 {
!                   /* For k=0 we can't decide exactness since it may depend
!                      from low order bits.
!                      For k=1, the first low limbs matched: low(b)-low(c)<0. */
!                   if (k)
!                     {
!                       inexact = 1;
!                       goto truncate;
!                     }
!                 }
!               else if (down && sh == 0)
!                 goto sub_one_ulp;
!               else
!                 {
!                   inexact = (is_exact) ? 1 : -1;
                    goto truncate;
                  }
              }
          }
!       else if (bb > cc)
          {
            if (rnd_mode == MPFR_RNDZ)
              {
--- 381,495 ----
        else
          cc = 0;
  
!       /* cmp_low compares low(b) and low(c) */
!       if (cmp_low == 0) /* case 1 or 3 */
!         cmp_low = (bb < cc) ? -2+k : (bb > cc) ? 1 : 0;
! 
!       /* Case 1 for k=0 splits into 7 subcases:
!          1a: bb > cc + half
!          1b: bb = cc + half
!          1c: 0 < bb - cc < half
!          1d: bb = cc
!          1e: -half < bb - cc < 0
!          1f: bb - cc = -half
!          1g: bb - cc < -half
! 
!          Case 2 splits into 3 subcases:
!          2a: bb > cc
!          2b: bb = cc
!          2c: bb < cc
! 
!          Case 3 splits into 3 subcases:
!          3a: bb > cc
!          3b: bb = cc
!          3c: bb < cc
!       */
  
        /* the case rounding to nearest with sh=0 is special since one couldn't
           subtract above 1/2 ulp in the trailing limb of the result */
!       if (rnd_mode == MPFR_RNDN && sh == 0 && k == 0) /* case 1 for k=0 */
          {
            mp_limb_t half = MPFR_LIMB_HIGHBIT;
  
            /* add one ulp if bb > cc + half
               truncate if cc - half < bb < cc + half
               sub one ulp if bb < cc - half
            */
  
!           if (cmp_low < 0) /* bb < cc: -1 ulp < low(b) - low(c) < 0,
!                               cases 1e, 1f and 1g */
              {
                if (cc >= half)
                  cc -= half;
!               else /* since bb < cc < half, bb+half < 2*half */
                  bb += half;
+               /* now we have bb < cc + half:
+                  we have to subtract one ulp if bb < cc,
+                  and truncate if bb > cc */
              }
!           else if (cmp_low >= 0) /* bb >= cc, cases 1a to 1d */
              {
                if (cc < half)
                  cc += half;
!               else /* since bb >= cc >= half, bb - half >= 0 */
                  bb -= half;
+               /* now we have bb > cc - half: we have to add one ulp if bb > cc,
+                  and truncate if bb < cc */
+               if (cmp_low > 0)
+                 cmp_low = 2;
              }
          }
  
  #ifdef DEBUG
!       printf ("k=%u bb=%lu cc=%lu cmp_low=%d\n", k,
!               (unsigned long) bb, (unsigned long) cc, cmp_low);
  #endif
!       if (cmp_low < 0) /* low(b) - low(c) < 0: either truncate or subtract
!                           one ulp */
          {
            if (rnd_mode == MPFR_RNDZ)
!             goto sub_one_ulp; /* set inexact=-1 */
            else if (rnd_mode != MPFR_RNDN) /* round away */
              {
                inexact = 1;
                goto truncate;
              }
!           else /* round to nearest */
              {
!               /* If cmp_low < 0 and bb > cc, then -0.5 ulp < low(b)-low(c) < 0,
!                  whatever the value of sh.
!                  If sh>0, then cmp_low < 0 implies that the initial neglected
!                  sh bits were 0 (otherwise cmp_low=2 initially), thus the
!                  weight of the new bits is less than 0.5 ulp too.
!                  If k > 0 (and sh=0) this means that either the first neglected
!                  limbs bb and cc were equal (thus cmp_low was 0 for k=0),
!                  or we had bb - cc = -0.5 ulp or 0.5 ulp.
!                  The last case is not possible here since we would have
!                  cmp_low > 0 which is sticky.
!                  In the first case (where we have cmp_low = -1), we truncate,
!                  whereas in the 2nd case we have cmp_low = -2 and we subtract
!                  one ulp.
!               */
!               if (bb > cc || sh > 0 || cmp_low == -1)
!                 {  /* -0.5 ulp < low(b)-low(c) < 0,
!                       bb > cc corresponds to cases 1e and 1f1
!                       sh > 0 corresponds to cases 3c and 3b3
!                       cmp_low = -1 corresponds to case 1d3 (also 3b3) */
!                   inexact = 1;
                    goto truncate;
                  }
+               else if (bb < cc) /* here sh = 0 and low(b)-low(c) < -0.5 ulp,
+                                    this corresponds to cases 1g and 1f3 */
+                 goto sub_one_ulp;
+               /* the only case where we can't conclude is sh=0 and bb=cc,
+                  i.e., we have low(b) - low(c) = -0.5 ulp (up to now), thus
+                  we don't know if we must truncate or subtract one ulp.
+                  Note: for sh=0 we can't have low(b) - low(c) = -0.5 ulp up to
+                  now, since low(b) - low(c) > 1/2^sh */
              }
          }
!       else if (cmp_low > 0) /* 0 < low(b) - low(c): either truncate or
!                                add one ulp */
          {
            if (rnd_mode == MPFR_RNDZ)
              {
***************
*** 437,470 ****
              goto add_one_ulp;
            else /* round to nearest */
              {
!               if (is_exact)
                  {
!                   inexact = -1;
!                   goto truncate;
                  }
!               else if (down)
                  {
!                   inexact = 1;
                    goto truncate;
                  }
!               else
!                 goto add_one_ulp;
!             }
!         }
      }
  
!   if ((rnd_mode == MPFR_RNDN) && !is_exact)
      {
        /* even rounding rule */
        if ((ap[0] >> sh) & 1)
          {
!           if (down)
              goto sub_one_ulp;
            else
              goto add_one_ulp;
          }
        else
!         inexact = (down) ? 1 : -1;
      }
    else
      inexact = 0;
--- 500,569 ----
              goto add_one_ulp;
            else /* round to nearest */
              {
!               if (bb > cc)
                  {
!                   /* if sh=0, then bb>cc means that low(b)-low(c) > 0.5 ulp,
!                      and similarly when cmp_low=2 */
!                   if (cmp_low == 2) /* cases 1a, 1b1, 2a and 2b1 */
!                     goto add_one_ulp;
!                   /* sh > 0 and cmp_low > 0: this implies that the sh initial
!                      neglected bits were 0, and the remaining low(b)-low(c)>0,
!                      but its weight is less than 0.5 ulp */
!                   else /* 0 < low(b) - low(c) < 0.5 ulp, this corresponds to
!                           cases 3a, 1d1 and 3b1 */
!                     {
!                       inexact = -1;
!                       goto truncate;
!                     }
                  }
!               else if (bb < cc) /* 0 < low(b) - low(c) < 0.5 ulp, cases 1c,
!                                    1b3, 2b3 and 2c */
                  {
!                   inexact = -1;
                    goto truncate;
                  }
!               /* the only case where we can't conclude is bb=cc, i.e.,
!                  low(b) - low(c) = 0.5 ulp (up to now), thus we don't know
!                  if we must truncate or add one ulp. */
!             }
!         }
!       /* after k=0, we cannot conclude in the following cases, we split them
!          according to the values of bb and cc for k=1:
!          1b. sh=0 and cmp_low = 1 and bb-cc = half [around 0.5 ulp]
!              1b1. bb > cc: add one ulp, inex = 1
!              1b2: bb = cc: cannot conclude
!              1b3: bb < cc: truncate, inex = -1
!          1d. sh=0 and cmp_low = 0 and bb-cc = 0 [around 0]
!              1d1: bb > cc: truncate, inex = -1
!              1d2: bb = cc: cannot conclude
!              1d3: bb < cc: truncate, inex = +1
!          1f. sh=0 and cmp_low = -1 and bb-cc = -half [around -0.5 ulp]
!              1f1: bb > cc: truncate, inex = +1
!              1f2: bb = cc: cannot conclude
!              1f3: bb < cc: sub one ulp, inex = -1
!          2b. sh > 0 and cmp_low = 2 and bb=cc [around 0.5 ulp]
!              2b1. bb > cc: add one ulp, inex = 1
!              2b2: bb = cc: cannot conclude
!              2b3: bb < cc: truncate, inex = -1
!          3b. sh > 0 and cmp_low = 0 [around 0]
!              3b1. bb > cc: truncate, inex = -1
!              3b2: bb = cc: cannot conclude
!              3b3: bb < cc: truncate, inex = +1
!       */
      }
  
!   if ((rnd_mode == MPFR_RNDN) && cmp_low != 0)
      {
        /* even rounding rule */
        if ((ap[0] >> sh) & 1)
          {
!           if (cmp_low < 0)
              goto sub_one_ulp;
            else
              goto add_one_ulp;
          }
        else
!         inexact = (cmp_low > 0) ? -1 : 1;
      }
    else
      inexact = 0;
diff -crB ../../original/mpfr-3.0.0/tests/Makefile.in ./tests/Makefile.in
*** ../../original/mpfr-3.0.0/tests/Makefile.in	2010-06-10 13:00:52.000000000 +0200
--- ./tests/Makefile.in	2010-06-10 13:00:52.000000000 +0200
***************
*** 960,965 ****
--- 960,966 ----
  red=; grn=; lgn=; blu=; std=
  DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
  ACLOCAL = @ACLOCAL@
+ ALLOCA = @ALLOCA@
  AMTAR = @AMTAR@
  AR = @AR@
  AS = @AS@
diff -crB ../../original/mpfr-3.0.0/tests/tcan_round.c ./tests/tcan_round.c
*** ../../original/mpfr-3.0.0/tests/tcan_round.c	2010-06-10 13:00:13.000000000 +0200
--- ./tests/tcan_round.c	2010-10-21 22:28:38.000000000 +0200
***************
*** 41,47 ****
        /* avoid mpn_random which leaks memory */
        for (i = 0; i < n; i++)
          buf[i] = randlimb ();
!       p = (mpfr_prec_t) randlimb() % ((n-1) * GMP_NUMB_BITS) + MPFR_PREC_MIN;
        err = p + randlimb () % GMP_NUMB_BITS;
        r1 = mpfr_round_p (buf, n, err, p);
        r2 = mpfr_can_round_raw (buf, n, MPFR_SIGN_POS, err,
--- 41,47 ----
        /* avoid mpn_random which leaks memory */
        for (i = 0; i < n; i++)
          buf[i] = randlimb ();
!       p = randlimb() % ((n-1) * GMP_NUMB_BITS) + MPFR_PREC_MIN;
        err = p + randlimb () % GMP_NUMB_BITS;
        r1 = mpfr_round_p (buf, n, err, p);
        r2 = mpfr_can_round_raw (buf, n, MPFR_SIGN_POS, err,
diff -crB ../../original/mpfr-3.0.0/tests/tcmp_ui.c ./tests/tcmp_ui.c
*** ../../original/mpfr-3.0.0/tests/tcmp_ui.c	2010-06-10 13:00:13.000000000 +0200
--- ./tests/tcmp_ui.c	2010-09-07 10:45:12.000000000 +0200
***************
*** 88,93 ****
--- 88,213 ----
    mpfr_clear (x);
  }
  
+ /* Since mpfr_cmp_ui and mpfr_cmp_si are also implemented by a macro
+    with __builtin_constant_p for GCC, check that side effects are
+    handled correctly. */
+ static void
+ check_macros (void)
+ {
+   mpfr_t x;
+   int c;
+ 
+   mpfr_init2 (x, 32);
+ 
+   c = 0;
+   mpfr_set_ui (x, 17, MPFR_RNDN);
+   if (mpfr_cmp_ui (x, 17) != 0)
+     {
+       printf ("Error 1 on mpfr_cmp_ui(x,17) in check_macros\n");
+       exit (1);
+     }
+   if (mpfr_cmp_ui (x, (c++, 17)) != 0)
+     {
+       printf ("Error 2 on mpfr_cmp_ui(x,17) in check_macros\n");
+       exit (1);
+     }
+   if (c != 1)
+     {
+       printf ("Error 3 on mpfr_cmp_ui(x,17) in check_macros\n"
+               "(c = %d instead of 1)\n", c);
+       exit (1);
+     }
+   if (mpfr_cmp_si (x, 17) != 0)
+     {
+       printf ("Error 1 on mpfr_cmp_si(x,17) in check_macros\n");
+       exit (1);
+     }
+   if (mpfr_cmp_si (x, (c++, 17)) != 0)
+     {
+       printf ("Error 2 on mpfr_cmp_si(x,17) in check_macros\n");
+       exit (1);
+     }
+   if (c != 2)
+     {
+       printf ("Error 3 on mpfr_cmp_si(x,17) in check_macros\n"
+               "(c = %d instead of 2)\n", c);
+       exit (1);
+     }
+ 
+   c = 0;
+   mpfr_set_ui (x, 0, MPFR_RNDN);
+   if (mpfr_cmp_ui (x, 0) != 0)
+     {
+       printf ("Error 1 on mpfr_cmp_ui(x,0) in check_macros\n");
+       exit (1);
+     }
+   if (mpfr_cmp_ui (x, (c++, 0)) != 0)
+     {
+       printf ("Error 2 on mpfr_cmp_ui(x,0) in check_macros\n");
+       exit (1);
+     }
+   if (c != 1)
+     {
+       printf ("Error 3 on mpfr_cmp_ui(x,0) in check_macros\n"
+               "(c = %d instead of 1)\n", c);
+       exit (1);
+     }
+   if (mpfr_cmp_si (x, 0) != 0)
+     {
+       printf ("Error 1 on mpfr_cmp_si(x,0) in check_macros\n");
+       exit (1);
+     }
+   if (mpfr_cmp_si (x, (c++, 0)) != 0)
+     {
+       printf ("Error 2 on mpfr_cmp_si(x,0) in check_macros\n");
+       exit (1);
+     }
+   if (c != 2)
+     {
+       printf ("Error 3 on mpfr_cmp_si(x,0) in check_macros\n"
+               "(c = %d instead of 2)\n", c);
+       exit (1);
+     }
+ 
+   mpfr_clear (x);
+ }
+ 
+ /* Bug in r7114 */
+ static void
+ test_macros (void)
+ {
+   mpfr_t x[3];
+   mpfr_ptr p;
+ 
+   mpfr_inits (x[0], x[1], x[2], (mpfr_ptr) 0);
+   mpfr_set_ui (x[0], 0, MPFR_RNDN);
+   p = x[0];
+   if (mpfr_cmp_ui (p++, 0) != 0)
+     {
+       printf ("Error in mpfr_cmp_ui macro: result should be 0.\n");
+       exit (1);
+     }
+   if (p != x[1])
+     {
+       printf ("Error in mpfr_cmp_ui macro: p - x[0] = %d (expecting 1)\n",
+               (int) (p - x[0]));
+       exit (1);
+     }
+   p = x[0];
+   if (mpfr_cmp_si (p++, 0) != 0)
+     {
+       printf ("Error in mpfr_cmp_si macro: result should be 0.\n");
+       exit (1);
+     }
+   if (p != x[1])
+     {
+       printf ("Error in mpfr_cmp_si macro: p - x[0] = %d (expecting 1)\n",
+               (int) (p - x[0]));
+       exit (1);
+     }
+   mpfr_clears (x[0], x[1], x[2], (mpfr_ptr) 0);
+ }
+ 
  int
  main (void)
  {
***************
*** 216,221 ****
--- 336,343 ----
    mpfr_clear (x);
  
    check_nan ();
+   check_macros ();
+   test_macros ();
  
    tests_end_mpfr ();
    return 0;
diff -crB ../../original/mpfr-3.0.0/tests/tfma.c ./tests/tfma.c
*** ../../original/mpfr-3.0.0/tests/tfma.c	2010-06-10 13:00:13.000000000 +0200
--- ./tests/tfma.c	2010-10-21 22:59:32.000000000 +0200
***************
*** 337,342 ****
--- 337,430 ----
    mpfr_clears (x, y, z, r, (mpfr_ptr) 0);
  }
  
+ static void
+ bug20101018 (void)
+ {
+   mpfr_t x, y, z, t, u;
+   int i;
+ 
+   mpfr_init2 (x, 64);
+   mpfr_init2 (y, 64);
+   mpfr_init2 (z, 64);
+   mpfr_init2 (t, 64);
+   mpfr_init2 (u, 64);
+ 
+   mpfr_set_str (x, "0xf.fffffffffffffffp-14766", 16, MPFR_RNDN);
+   mpfr_set_str (y, "-0xf.fffffffffffffffp+317", 16, MPFR_RNDN);
+   mpfr_set_str (z, "0x8.3ffffffffffe3ffp-14443", 16, MPFR_RNDN);
+   mpfr_set_str (t, "0x8.7ffffffffffc7ffp-14444", 16, MPFR_RNDN);
+   i = mpfr_fma (u, x, y, z, MPFR_RNDN);
+   if (mpfr_cmp (u, t) != 0)
+     {
+       printf ("Wrong result in bug20101018 (a)\n");
+       printf ("Expected ");
+       mpfr_out_str (stdout, 16, 0, t, MPFR_RNDN);
+       printf ("\nGot      ");
+       mpfr_out_str (stdout, 16, 0, u, MPFR_RNDN);
+       printf ("\n");
+       exit (1);
+     }
+   if (i <= 0)
+     {
+       printf ("Wrong ternary value in bug20101018 (a)\n");
+       printf ("Expected > 0\n");
+       printf ("Got      %d\n", i);
+       exit (1);
+     }
+ 
+   mpfr_set_str (x, "-0xf.fffffffffffffffp-11420", 16, MPFR_RNDN);
+   mpfr_set_str (y, "0xf.fffffffffffffffp+9863", 16, MPFR_RNDN);
+   mpfr_set_str (z, "0x8.fffff80ffffffffp-1551", 16, MPFR_RNDN);
+   mpfr_set_str (t, "0x9.fffff01ffffffffp-1552", 16, MPFR_RNDN);
+   i = mpfr_fma (u, x, y, z, MPFR_RNDN);
+   if (mpfr_cmp (u, t) != 0)
+     {
+       printf ("Wrong result in bug20101018 (b)\n");
+       printf ("Expected ");
+       mpfr_out_str (stdout, 16, 0, t, MPFR_RNDN);
+       printf ("\nGot      ");
+       mpfr_out_str (stdout, 16, 0, u, MPFR_RNDN);
+       printf ("\n");
+       exit (1);
+     }
+   if (i <= 0)
+     {
+       printf ("Wrong ternary value in bug20101018 (b)\n");
+       printf ("Expected > 0\n");
+       printf ("Got      %d\n", i);
+       exit (1);
+     }
+ 
+   mpfr_set_str (x, "0xf.fffffffffffffffp-2125", 16, MPFR_RNDN);
+   mpfr_set_str (y, "-0xf.fffffffffffffffp-6000", 16, MPFR_RNDN);
+   mpfr_set_str (z, "0x8p-8119", 16, MPFR_RNDN);
+   mpfr_set_str (t, "0x8.000000000000001p-8120", 16, MPFR_RNDN);
+   i = mpfr_fma (u, x, y, z, MPFR_RNDN);
+   if (mpfr_cmp (u, t) != 0)
+     {
+       printf ("Wrong result in bug20101018 (c)\n");
+       printf ("Expected ");
+       mpfr_out_str (stdout, 16, 0, t, MPFR_RNDN);
+       printf ("\nGot      ");
+       mpfr_out_str (stdout, 16, 0, u, MPFR_RNDN);
+       printf ("\n");
+       exit (1);
+     }
+   if (i <= 0)
+     {
+       printf ("Wrong ternary value in bug20101018 (c)\n");
+       printf ("Expected > 0\n");
+       printf ("Got      %d\n", i);
+       exit (1);
+     }
+ 
+   mpfr_clear (x);
+   mpfr_clear (y);
+   mpfr_clear (z);
+   mpfr_clear (t);
+   mpfr_clear (u);
+ }
+ 
  int
  main (int argc, char *argv[])
  {
***************
*** 345,350 ****
--- 433,440 ----
  
    tests_start_mpfr ();
  
+   bug20101018 ();
+ 
    mpfr_init (x);
    mpfr_init (s);
    mpfr_init (y);
diff -crB ../../original/mpfr-3.0.0/tests/tgamma.c ./tests/tgamma.c
*** ../../original/mpfr-3.0.0/tests/tgamma.c	2010-06-10 13:00:13.000000000 +0200
--- ./tests/tgamma.c	2010-07-10 02:11:46.000000000 +0200
***************
*** 461,466 ****
--- 461,480 ----
    mpfr_clear (x);
  }
  
+ /* bug found by Stathis, only occurs on 32-bit machines */
+ static void
+ test20100709 (void)
+ {
+   mpfr_t x;
+   int inex;
+ 
+   mpfr_init2 (x, 100);
+   mpfr_set_str (x, "-4.6308260837372266e+07", 10, MPFR_RNDN);
+   inex = mpfr_gamma (x, x, MPFR_RNDN);
+   MPFR_ASSERTN(MPFR_IS_ZERO(x) && MPFR_IS_NEG(x) && inex > 0);
+   mpfr_clear (x);
+ }
+ 
  int
  main (int argc, char *argv[])
  {
***************
*** 471,476 ****
--- 485,491 ----
    test_generic (2, 100, 2);
    gamma_integer ();
    test20071231 ();
+   test20100709 ();
  
    data_check ("data/gamma", mpfr_gamma, "mpfr_gamma");
  
diff -crB ../../original/mpfr-3.0.0/tests/tout_str.c ./tests/tout_str.c
*** ../../original/mpfr-3.0.0/tests/tout_str.c	2010-06-10 13:00:13.000000000 +0200
--- ./tests/tout_str.c	2010-06-23 13:03:12.000000000 +0200
***************
*** 46,67 ****
  special (void)
  {
    mpfr_t x;
  
    mpfr_init (x);
  
    mpfr_set_nan (x);
!   mpfr_out_str (fout, 10, 0, x, MPFR_RNDN);
  
    mpfr_set_inf (x, 1);
!   mpfr_out_str (fout, 10, 0, x, MPFR_RNDN);
  
    mpfr_set_inf (x, -1);
!   mpfr_out_str (fout, 10, 0, x, MPFR_RNDN);
  
    mpfr_set_ui (x, 0, MPFR_RNDN);
!   mpfr_out_str (fout, 10, 0, x, MPFR_RNDN);
    mpfr_neg (x, x, MPFR_RNDN);
!   mpfr_out_str (fout, 10, 0, x, MPFR_RNDN);
  
    mpfr_clear (x);
  }
--- 46,99 ----
  special (void)
  {
    mpfr_t x;
+   unsigned int n;
  
    mpfr_init (x);
  
    mpfr_set_nan (x);
!   n = mpfr_out_str (fout, 10, 0, x, MPFR_RNDN);
!   if (n != 5)
!     {
!       printf ("Error: mpfr_out_str (file, 10, 0, NaN, MPFR_RNDN) wrote %u "
!               "characters instead of 5.\n", n);
!       exit (1);
!     }
  
    mpfr_set_inf (x, 1);
!   n = mpfr_out_str (fout, 10, 0, x, MPFR_RNDN);
!   if (n != 5)
!     {
!       printf ("Error: mpfr_out_str (file, 10, 0, +Inf, MPFR_RNDN) wrote %u "
!                "characters instead of 5.\n", n);
!       exit (1);
!     }
  
    mpfr_set_inf (x, -1);
!   n = mpfr_out_str (fout, 10, 0, x, MPFR_RNDN);
!   if (n != 6)
!     {
!       printf ("Error: mpfr_out_str (file, 10, 0, -Inf, MPFR_RNDN) wrote %u "
!                "characters instead of 6.\n", n);
!       exit (1);
!     }
  
    mpfr_set_ui (x, 0, MPFR_RNDN);
!   n = mpfr_out_str (fout, 10, 0, x, MPFR_RNDN);
!   if (n != 1)
!     {
!       printf ("Error: mpfr_out_str (file, 10, 0, +0, MPFR_RNDN) wrote %u "
!                "characters instead of 1.\n", n);
!       exit (1);
!     }
! 
    mpfr_neg (x, x, MPFR_RNDN);
!   n = mpfr_out_str (fout, 10, 0, x, MPFR_RNDN);
!   if (n != 2)
!     {
!       printf ("Error: mpfr_out_str (file, 10, 0, -0, MPFR_RNDN) wrote %u "
!                "characters instead of 2.\n", n);
!       exit (1);
!     }
  
    mpfr_clear (x);
  }
diff -crB ../../original/mpfr-3.0.0/tests/tset_ld.c ./tests/tset_ld.c
*** ../../original/mpfr-3.0.0/tests/tset_ld.c	2010-06-10 13:00:13.000000000 +0200
--- ./tests/tset_ld.c	2010-10-21 23:18:26.000000000 +0200
***************
*** 147,158 ****
  test_fixed_bugs (void)
  {
    mpfr_t x;
!   long double d;
  
    /* bug found by Steve Kargl (2009-03-14) */
    mpfr_init2 (x, 64);
    mpfr_set_ui_2exp (x, 1, -16447, MPFR_RNDN);
!   d = mpfr_get_ld (x, MPFR_RNDN);  /* an assertion failed in init2.c:50 */
  
    mpfr_clear (x);
  }
--- 147,185 ----
  test_fixed_bugs (void)
  {
    mpfr_t x;
!   long double l, m;
  
    /* bug found by Steve Kargl (2009-03-14) */
    mpfr_init2 (x, 64);
    mpfr_set_ui_2exp (x, 1, -16447, MPFR_RNDN);
!   mpfr_get_ld (x, MPFR_RNDN);  /* an assertion failed in init2.c:50 */
! 
!   /* bug reported by Jakub Jelinek (2010-10-17)
!      https://gforge.inria.fr/tracker/?func=detail&aid=11300 */
!   mpfr_set_prec (x, MPFR_LDBL_MANT_DIG);
!   /* l = 0x1.23456789abcdef0123456789abcdp-914L; */
!   l = 8.215640181713713164092636634579e-276;
!   mpfr_set_ld (x, l, MPFR_RNDN);
!   m = mpfr_get_ld (x, MPFR_RNDN);
!   if (m != l)
!     {
!       printf ("Error in get_ld o set_ld for l=%Le\n", l);
!       printf ("Got m=%Le instead of l\n", m);
!       exit (1);
!     }
! 
!   /* another similar test which failed with extended double precision and the
!      generic code for mpfr_set_ld */
!   /* l = 0x1.23456789abcdef0123456789abcdp-968L; */
!   l = 4.560596445887084662336528403703e-292;
!   mpfr_set_ld (x, l, MPFR_RNDN);
!   m = mpfr_get_ld (x, MPFR_RNDN);
!   if (m != l)
!     {
!       printf ("Error in get_ld o set_ld for l=%Le\n", l);
!       printf ("Got m=%Le instead of l\n", m);
!       exit (1);
!     }
  
    mpfr_clear (x);
  }
diff -crB ../../original/mpfr-3.0.0/tests/tsub.c ./tests/tsub.c
*** ../../original/mpfr-3.0.0/tests/tsub.c	2010-06-10 13:00:13.000000000 +0200
--- ./tests/tsub.c	2010-10-21 22:59:32.000000000 +0200
***************
*** 201,206 ****
--- 201,208 ----
    if (mpfr_cmp (z, x))
      {
        printf ("Error in mpfr_sub (2)\n");
+       printf ("Expected "); mpfr_print_binary (x); puts ("");
+       printf ("Got      "); mpfr_print_binary (z); puts ("");
        exit (1);
      }
    mpfr_set_str_binary (x, "1.1110111011110001110111011111111111101000011001011100101100101101");
***************
*** 478,483 ****
--- 480,635 ----
    mpfr_clear (u);
  }
  
+ /* Bug found by Jakub Jelinek
+  * http://bugzilla.redhat.com/643657
+  * https://gforge.inria.fr/tracker/index.php?func=detail&aid=11301
+  * The consequence can be either an assertion failure (i = 2 in the
+  * testcase below, in debug mode) or an incorrectly rounded value.
+  */
+ static void
+ bug20101017 (void)
+ {
+   mpfr_t a, b, c;
+   int inex;
+   int i;
+ 
+   mpfr_init2 (a, GMP_NUMB_BITS * 2);
+   mpfr_init2 (b, GMP_NUMB_BITS);
+   mpfr_init2 (c, GMP_NUMB_BITS);
+ 
+   /* a = 2^(2N) + k.2^(2N-1) + 2^N and b = 1
+      with N = GMP_NUMB_BITS and k = 0 or 1.
+      c = a - b should round to the same value as a. */
+ 
+   for (i = 2; i <= 3; i++)
+     {
+       mpfr_set_ui_2exp (a, i, GMP_NUMB_BITS - 1, MPFR_RNDN);
+       mpfr_add_ui (a, a, 1, MPFR_RNDN);
+       mpfr_mul_2ui (a, a, GMP_NUMB_BITS, MPFR_RNDN);
+       mpfr_set_ui (b, 1, MPFR_RNDN);
+       inex = mpfr_sub (c, a, b, MPFR_RNDN);
+       mpfr_set (b, a, MPFR_RNDN);
+       if (! mpfr_equal_p (c, b))
+         {
+           printf ("Error in bug20101017 for i = %d.\n", i);
+           printf ("Expected ");
+           mpfr_out_str (stdout, 16, 0, b, MPFR_RNDN);
+           putchar ('\n');
+           printf ("Got      ");
+           mpfr_out_str (stdout, 16, 0, c, MPFR_RNDN);
+           putchar ('\n');
+           exit (1);
+         }
+       if (inex >= 0)
+         {
+           printf ("Error in bug20101017 for i = %d: bad inex value.\n", i);
+           printf ("Expected negative, got %d.\n", inex);
+           exit (1);
+         }
+     }
+ 
+   mpfr_set_prec (a, 64);
+   mpfr_set_prec (b, 129);
+   mpfr_set_prec (c, 2);
+   mpfr_set_str_binary (b, "0.100000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000001E65");
+   mpfr_set_str_binary (c, "0.10E1");
+   inex = mpfr_sub (a, b, c, MPFR_RNDN);
+   if (mpfr_cmp_ui_2exp (a, 1, 64) != 0 || inex >= 0)
+     {
+       printf ("Error in mpfr_sub for b-c for b=2^64+1+2^(-64), c=1\n");
+       printf ("Expected result 2^64 with inex < 0\n");
+       printf ("Got "); mpfr_print_binary (a);
+       printf (" with inex=%d\n", inex);
+       exit (1);
+     }
+ 
+   mpfr_clears (a, b, c, (mpfr_ptr) 0);
+ }
+ 
+ /* hard test of rounding */
+ static void
+ check_rounding (void)
+ {
+   mpfr_t a, b, c, res;
+   mpfr_prec_t p;
+   long k, l;
+   int i;
+ 
+ #define MAXKL (2 * GMP_NUMB_BITS)
+   for (p = MPFR_PREC_MIN; p <= GMP_NUMB_BITS; p++)
+     {
+       mpfr_init2 (a, p);
+       mpfr_init2 (res, p);
+       mpfr_init2 (b, p + 1 + MAXKL);
+       mpfr_init2 (c, MPFR_PREC_MIN);
+ 
+       /* b = 2^p + 1 + 2^(-k), c = 2^(-l) */
+       for (k = 0; k <= MAXKL; k++)
+         for (l = 0; l <= MAXKL; l++)
+           {
+             mpfr_set_ui_2exp (b, 1, p, MPFR_RNDN);
+             mpfr_add_ui (b, b, 1, MPFR_RNDN);
+             mpfr_mul_2ui (b, b, k, MPFR_RNDN);
+             mpfr_add_ui (b, b, 1, MPFR_RNDN);
+             mpfr_div_2ui (b, b, k, MPFR_RNDN);
+             mpfr_set_ui_2exp (c, 1, -l, MPFR_RNDN);
+             i = mpfr_sub (a, b, c, MPFR_RNDN);
+             /* b - c = 2^p + 1 + 2^(-k) - 2^(-l), should be rounded to
+                2^p for l <= k, and 2^p+2 for l < k */
+             if (l <= k)
+               {
+                 if (mpfr_cmp_ui_2exp (a, 1, p) != 0)
+                   {
+                     printf ("Wrong result in check_rounding\n");
+                     printf ("p=%lu k=%ld l=%ld\n", p, k, l);
+                     printf ("b="); mpfr_print_binary (b); puts ("");
+                     printf ("c="); mpfr_print_binary (c); puts ("");
+                     printf ("Expected 2^%lu\n", p);
+                     printf ("Got      "); mpfr_print_binary (a); puts ("");
+                     exit (1);
+                   }
+                 if (i >= 0)
+                   {
+                     printf ("Wrong ternary value in check_rounding\n");
+                     printf ("p=%lu k=%ld l=%ld\n", p, k, l);
+                     printf ("b="); mpfr_print_binary (b); puts ("");
+                     printf ("c="); mpfr_print_binary (c); puts ("");
+                     printf ("a="); mpfr_print_binary (a); puts ("");
+                     printf ("Expected < 0, got %d\n", i);
+                     exit (1);
+                   }
+               }
+             else /* l < k */
+               {
+                 mpfr_set_ui_2exp (res, 1, p, MPFR_RNDN);
+                 mpfr_add_ui (res, res, 2, MPFR_RNDN);
+                 if (mpfr_cmp (a, res) != 0)
+                   {
+                     printf ("Wrong result in check_rounding\n");
+                     printf ("b="); mpfr_print_binary (b); puts ("");
+                     printf ("c="); mpfr_print_binary (c); puts ("");
+                     printf ("Expected "); mpfr_print_binary (res); puts ("");
+                     printf ("Got      "); mpfr_print_binary (a); puts ("");
+                     exit (1);
+                   }
+                 if (i <= 0)
+                   {
+                     printf ("Wrong ternary value in check_rounding\n");
+                     printf ("b="); mpfr_print_binary (b); puts ("");
+                     printf ("c="); mpfr_print_binary (c); puts ("");
+                     printf ("Expected > 0, got %d\n", i);
+                     exit (1);
+                   }
+               }
+           }
+ 
+       mpfr_clear (a);
+       mpfr_clear (res);
+       mpfr_clear (b);
+       mpfr_clear (c);
+     }
+ }
+ 
  #define TEST_FUNCTION test_sub
  #define TWO_ARGS
  #define RAND_FUNCTION(x) mpfr_random2(x, MPFR_LIMB_SIZE (x), randlimb () % 100, RANDS)
***************
*** 491,496 ****
--- 643,650 ----
  
    tests_start_mpfr ();
  
+   bug20101017 ();
+   check_rounding ();
    check_diverse ();
    check_inexact ();
    bug_ddefour ();
diff -crB ../../original/mpfr-3.0.0/VERSION ./VERSION
*** ../../original/mpfr-3.0.0/VERSION	2010-06-10 13:00:14.000000000 +0200
--- ./VERSION	2010-11-09 16:15:07.000000000 +0100
***************
*** 1 ****
! 3.0.0
--- 1 ----
! 3.0.0-p8
diff -crB ../../original/mpfr-3.0.0/version.c ./version.c
*** ../../original/mpfr-3.0.0/version.c	2010-06-10 13:00:14.000000000 +0200
--- ./version.c	2010-11-09 16:15:07.000000000 +0100
***************
*** 25,29 ****
  const char *
  mpfr_get_version (void)
  {
!   return "3.0.0";
  }
--- 25,29 ----
  const char *
  mpfr_get_version (void)
  {
!   return "3.0.0-p8";
  }
